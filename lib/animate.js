// Generated by CoffeeScript 1.9.3
var c, checkForWin, i, len, ref,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

this.count = 0;


/* Moves the connector to the correct lit layer */

this.toLit = function(connector) {
  var c;
  try {
    this.colorContainers[connector.color].unlit.removeChild(connector.panel);
  } catch (_error) {

  }
  if (this.typeIsArray(connector.color)) {
    if (connector.color.length > 0) {
      c = connector.color[0].toUpperCase();
    } else {
      c = Color.asString(Color.NONE).toUpperCase();
    }
  } else {
    c = connector.color.toUpperCase();
  }
  if (c === Color.asString(Color.NONE).toUpperCase()) {
    this.toUnlit(connector);
  } else {
    this.colorContainers[c.toUpperCase()].lit.addChild(connector.panel);
    connector.linked = true;
  }
};


/* Moves the connector to the correct unlit layer */

this.toUnlit = function(connector) {
  var c;
  try {
    this.colorContainers[connector.color].lit.removeChild(connector.panel);
  } catch (_error) {

  }
  if (this.typeIsArray(connector.color)) {
    if (connector.color.length > 0) {
      c = connector.color[0];
    } else {
      c = Color.asString(Color.NONE);
    }
  } else {
    c = connector.color;
  }
  if ((connector.hex != null) && connector.hex instanceof Crystal) {
    this.colorContainers[Color.asString(Color.NONE).toUpperCase()].unlit.addChild(connector.panel);
  } else {
    this.colorContainers[c.toUpperCase()].unlit.addChild(connector.panel);
  }
  connector.linked = false;
};


/* Creates a frame offset for the each color */

this.colorOffset = {};

ref = Color.values();
for (i = 0, len = ref.length; i < len; i++) {
  c = ref[i];
  if (!isNaN(c)) {
    c = Color.fromString(c).toUpperCase();
  } else {
    c = c.toUpperCase();
  }
  this.colorOffset[c] = Math.random() + 0.5;
}

checkForWin = function() {
  var curLit, goalContainer, j, k, len1, len2, pan, ref1, ref2, spr;
  curLit = this.BOARD.crystalLitCount();
  goalContainer = this.menu.children[this.goalContainerIndex];
  ref1 = goalContainer.children;
  for (j = 0, len1 = ref1.length; j < len1; j++) {
    pan = ref1[j];
    ref2 = pan.children;
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      spr = ref2[k];
      if (spr instanceof PIXI.Text && spr.color.toUpperCase() in curLit) {
        spr.setText(curLit[spr.color.toUpperCase()] + spr.text.substring(1));
        if (curLit[spr.color.toUpperCase()] < parseInt(spr.text.substring(2))) {
          return false;
        }
      }
    }
  }
  return true;
};


/* The animation function. Called by pixi and requests to be recalled */

this.animate = function() {
  var col, connector, curLit, goalContainer, h, hLit, inc, j, k, l, len1, len10, len11, len12, len13, len14, len2, len3, len4, len5, len6, len7, len8, len9, m, n, nConnector, nPanel, nS, nSide, newSides, o, p, panel, q, r, radTo60Degree, ref1, ref10, ref11, ref12, ref13, ref14, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, rotSpeed, s, side, spr, t, tolerance, u, v, value, w, x;
  window.count += 1;
  rotSpeed = 1 / 5;
  tolerance = 0.000001;
  radTo60Degree = 1.04719755;
  if ((this.BOARD != null)) {
    curLit = this.BOARD.crystalLitCount();
    goalContainer = this.menu.children[this.goalContainerIndex];
    if (checkForWin() && (this.winContainer == null) && this.showWinContainer) {
      this.gameOn = false;
      this.makeWinGameContainer();
    }
    ref1 = this.BOARD.allHexes();
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      h = ref1[j];
      if (h.isLit().length > 0 && !h.backPanel.children[0].lit) {
        h.backPanel.children[0].lit = true;
        if (!(h instanceof Prism)) {
          this.toLit(h.backPanel.spr);
        }
      }
      if (h.isLit().length === 0 && h.backPanel.children[0].lit) {
        h.backPanel.children[0].lit = false;
        if (!(h instanceof Prism)) {
          this.toUnlit(h.backPanel.spr);
        }
      }
      hLit = h.isLit();
      nS = h.getNeighborsWithBlanks();
      ref2 = h.colorPanels;
      for (k = 0, len2 = ref2.length; k < len2; k++) {
        panel = ref2[k];
        col = panel.color.toLowerCase();
        ref3 = panel.children;
        for (l = 0, len3 = ref3.length; l < len3; l++) {
          connector = ref3[l];
          ref4 = connector.sides;
          for (m = 0, len4 = ref4.length; m < len4; m++) {
            side = ref4[m];
            n = nS[side];
            if ((n != null) && indexOf.call(hLit, col) >= 0 && n.colorOfSide(n.indexLinked(h)) === col && !connector.linked) {
              this.toLit(connector);
              ref5 = n.colorPanels;
              for (o = 0, len5 = ref5.length; o < len5; o++) {
                nPanel = ref5[o];
                ref6 = nPanel.children;
                for (p = 0, len6 = ref6.length; p < len6; p++) {
                  nConnector = ref6[p];
                  ref7 = nConnector.sides;
                  for (q = 0, len7 = ref7.length; q < len7; q++) {
                    nSide = ref7[q];
                    if (nSide === n.indexLinked(h) && !nConnector.linked) {
                      this.toLit(nConnector);
                    }
                  }
                }
              }
            } else if (connector.linked && indexOf.call(hLit, col) < 0) {
              this.toUnlit(connector);
              if (n != null) {
                ref8 = n.colorPanels;
                for (r = 0, len8 = ref8.length; r < len8; r++) {
                  nPanel = ref8[r];
                  ref9 = nPanel.children;
                  for (s = 0, len9 = ref9.length; s < len9; s++) {
                    nConnector = ref9[s];
                    ref10 = nConnector.sides;
                    for (t = 0, len10 = ref10.length; t < len10; t++) {
                      nSide = ref10[t];
                      if (nSide === n.indexLinked(h) && !nConnector.linked) {
                        this.toUnlit(nConnector);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      /* Rotation of a prism - finds a prism that wants to rotate and rotates it a bit.
          If this is the first notification that this prism wants to rotate, stops providing light.
          If the prism is now done rotating, starts providing light again
       */
      if (h instanceof Prism && h.currentRotation !== h.targetRotation) {
        if (h.canLight) {
          h.canLight = false;
          h.light();
        }
        inc = (h.targetRotation - h.prevRotation) >= 0 ? rotSpeed : -rotSpeed;
        h.backPanel.rotation += inc * radTo60Degree;
        h.currentRotation += inc;
        ref11 = h.colorPanels;
        for (u = 0, len11 = ref11.length; u < len11; u++) {
          value = ref11[u];
          value.rotation += inc * radTo60Degree;
        }
        if (Math.abs(h.targetRotation - h.currentRotation) < tolerance) {
          inc = h.targetRotation - h.currentRotation;
          h.backPanel.rotation += inc * radTo60Degree;
          h.currentRotation += inc;
          ref12 = h.colorPanels;
          for (v = 0, len12 = ref12.length; v < len12; v++) {
            value = ref12[v];
            value.rotation += inc * radTo60Degree;
            ref13 = value.children;
            for (w = 0, len13 = ref13.length; w < len13; w++) {
              spr = ref13[w];
              newSides = [];
              ref14 = spr.sides;
              for (x = 0, len14 = ref14.length; x < len14; x++) {
                side = ref14[x];
                newSides.push(modulo(side + (h.currentRotation - h.prevRotation), Hex.SIDES));
              }
              spr.sides = newSides;
            }
          }
          h.prevRotation = h.currentRotation;
          h.canLight = true;
          h.light();
        }
      }

      /* Spark and crystal color changing */
      if ((h instanceof Spark || h instanceof Crystal) && h.toColor !== "") {
        col = !isNaN(h.toColor) ? Color.asString(h.toColor).toUpperCase() : h.toColor.toUpperCase();
        h.backPanel.spr.color = col;
        this.toLit(h.backPanel.spr);
        h.toColor = "";
      }
    }
  }
  requestAnimFrame(animate);
  this.renderer.render(this.stage);
};


/* The window resize function. Called whenever the window is resized, and by some other functions after they add elements */

this.resize = function() {
  var bck, cContainer, col, dumSpr, easyButton, effectiveCount, fixY, fixYRowTwo, goalContainer, hardButton, helpBack, helpButton, helpGoalHighlight, helpGoalText, helpHeight, helpWidth, icon, j, len1, lvlPush, lvlText, margin, medButton, menuHeight, menumargin, n, newScale2, newScale3, newX, nextLvl, prevLvl, ref1, ref2, ref3, resetButton, scale, subPane, subPaneArr, title;
  margin = 0;
  window.renderer.resize(window.innerWidth - margin, window.innerHeight - margin);
  newScale2 = Math.min(1, Math.max(0.5, window.innerHeight / 1500));
  newScale3 = newScale2 * 0.5;
  if ((this.menu != null) && this.menu.children.length > 0) {
    bck = this.menu.children[0];
    icon = this.menu.children[1];
    title = this.menu.children[2];
    prevLvl = this.menu.children[3];
    lvlText = this.menu.children[4];
    nextLvl = this.menu.children[5];
    resetButton = this.menu.children[6];
    helpButton = this.menu.children[7];
    easyButton = this.menu.children[8];
    medButton = this.menu.children[9];
    hardButton = this.menu.children[10];
    goalContainer = this.menu.children[this.goalContainerIndex];
    bck.scale.x = Math.max(window.innerWidth / bck.texture.baseTexture.width, 0.75);
    bck.scale.y = Math.max(window.innerHeight / bck.texture.baseTexture.height, 0.75);
    menuHeight = 75;
    this.base.position.y = menuHeight;
    ref1 = this.colorContainers;
    for (col in ref1) {
      cContainer = ref1[col];
      cContainer.position.y = menuHeight;
    }
    menumargin = 20;
    lvlPush = function(n) {
      if (this.level + n >= 10) {
        return 5;
      } else {
        return 0;
      }
    };
    prevLvl.position.x = menumargin;
    lvlText.position.x = prevLvl.position.x + 50 + lvlPush(-1);
    nextLvl.position.x = lvlText.position.x + 75 + lvlPush(0);
    resetButton.position.x = nextLvl.position.x + 60 + lvlPush(1);
    icon.position.x = (window.innerWidth - 125) / 2;
    title.position.x = (window.innerWidth - 50) / 2;
    helpButton.position.x = window.innerWidth - menumargin - 40;
    hardButton.position.x = helpButton.position.x;
    medButton.position.x = hardButton.position.x - 60;
    easyButton.position.x = medButton.position.x - 60;
    fixY = function(comp, scale) {
      comp.position.y = 45 * scale;
    };
    fixY(icon, newScale3);
    icon.position.y -= 4;
    fixY(title, newScale3);
    title.position.y -= 5;
    fixY(lvlText, newScale3);
    fixY(resetButton, newScale3);
    fixY(helpButton, newScale3);
    fixY(nextLvl, newScale3);
    fixY(prevLvl, newScale3);
    fixYRowTwo = function(comp, scale) {
      comp.position.y = 45 * scale + 35;
    };
    fixYRowTwo(easyButton, newScale3);
    fixYRowTwo(medButton, newScale3);
    fixYRowTwo(hardButton, newScale3);
    if (goalContainer != null) {
      goalContainer.position.y = -75;
      goalContainer.position.x = helpButton.position.x - 90 * goalContainer.count;
    }
  }
  if (this.helpContainer != null) {
    helpWidth = this.helpContainer.children[3].getLocalBounds().width * this.helpContainer.children[3].scale.x;
    helpHeight = this.helpContainer.children[3].getLocalBounds().height * this.helpContainer.children[3].scale.y;
    this.helpContainer.position.x = (window.innerWidth - helpWidth) / 2;
    this.helpContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
    helpBack = this.helpContainer.children[0];
    helpBack.position.x = -this.helpContainer.position.x - 15;
    helpBack.position.y = -this.helpContainer.position.y - 15;
    helpBack.height = window.innerHeight + 25;
    helpBack.width = window.innerWidth + 25;
    if (goalContainer != null) {
      helpGoalHighlight = this.helpContainer.children[1];
      helpGoalHighlight.position.y = -this.helpContainer.position.y;
      effectiveCount = Math.max(3, goalContainer.count);
      helpGoalHighlight.scale.x = 90 * effectiveCount / 100;
      helpGoalHighlight.position.x = (helpButton.position.x - 90 * effectiveCount) - this.helpContainer.position.x - helpGoalHighlight.scale.x * 11 - 20;
      helpGoalText = this.helpContainer.children[2];
      helpGoalText.position.y = -this.helpContainer.position.y + 40;
      helpGoalText.position.x = helpGoalHighlight.position.x + 8 + 9 * effectiveCount;
    }
  }
  if (this.winContainer != null) {
    helpWidth = this.winContainer.getLocalBounds().width;
    helpHeight = this.winContainer.getLocalBounds().height;
    this.winContainer.position.x = (window.innerWidth - helpWidth) / 2;
    this.winContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
  }
  if (this.BOARD != null) {
    scale = (1 / 130) * Math.min((window.innerHeight - menuHeight) / window.BOARD.getHeight(), window.innerWidth * 1.15 / window.BOARD.getWidth());
    this.base.scale.x = scale;
    this.base.scale.y = scale;
    ref2 = this.colorContainers;
    for (col in ref2) {
      cContainer = ref2[col];
      cContainer.scale.x = scale;
      cContainer.scale.y = scale;
    }
    n = this.hexRad * this.base.scale.x;
    newX = (window.innerWidth - window.BOARD.getWidth() * n) / 2 + 20;
    this.base.position.x = newX;
    ref3 = this.colorContainers;
    for (col in ref3) {
      cContainer = ref3[col];
      cContainer.position.x = newX;
      subPaneArr = [cContainer.lit, cContainer.unlit];
      for (j = 0, len1 = subPaneArr.length; j < len1; j++) {
        subPane = subPaneArr[j];
        dumSpr = subPane.children[0];
        dumSpr.position.x = -cContainer.position.x;
        dumSpr.position.y = -cContainer.position.y;
        dumSpr.height = (window.innerHeight + menuHeight) / scale;
        dumSpr.width = window.innerWidth;
      }
    }
  }
};
