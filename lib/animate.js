// Generated by CoffeeScript 1.7.1
(function() {
  var c, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __modulo = function(a, b) { return (a % b + +b) % b; };

  this.count = 0;


  /* Moves the connector to the correct lit layer */

  this.toLit = function(connector) {
    var c;
    try {
      this.colorContainers[connector.color].unlit.removeChild(connector.panel);
    } catch (_error) {

    }
    if (this.typeIsArray(connector.color)) {
      if (connector.color.length > 0) {
        c = connector.color[0].toUpperCase();
      } else {
        c = Color.asString(Color.NONE).toUpperCase();
      }
    } else {
      c = connector.color.toUpperCase();
    }
    if (c === Color.asString(Color.NONE).toUpperCase()) {
      this.toUnlit(connector);
    } else {
      this.colorContainers[c.toUpperCase()].lit.addChild(connector.panel);
      connector.linked = true;
    }
  };


  /* Moves the connector to the correct unlit layer */

  this.toUnlit = function(connector) {
    var c;
    try {
      this.colorContainers[connector.color].lit.removeChild(connector.panel);
    } catch (_error) {

    }
    if (this.typeIsArray(connector.color)) {
      if (connector.color.length > 0) {
        c = connector.color[0];
      } else {
        c = Color.asString(Color.NONE);
      }
    } else {
      c = connector.color;
    }
    if ((connector.hex != null) && connector.hex instanceof Crystal) {
      this.colorContainers[Color.asString(Color.NONE).toUpperCase()].unlit.addChild(connector.panel);
    } else {
      this.colorContainers[c.toUpperCase()].unlit.addChild(connector.panel);
    }
    connector.linked = false;
  };


  /* Creates a frame offset for the each color */

  this.colorOffset = {};

  _ref = Color.values();
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    c = _ref[_i];
    if (!isNaN(c)) {
      c = Color.fromString(c).toUpperCase();
    } else {
      c = c.toUpperCase();
    }
    this.colorOffset[c] = Math.random() + 0.5;
  }


  /* Updates the pulse filter that controls lighting effects */

  this.calcPulseFilter = function(count) {
    var col, cont, correspondCont, m, pulse, val, _j, _len1, _ref1, _ref2;
    _ref1 = this.colorContainers;
    for (col in _ref1) {
      val = _ref1[col];
      pulse = val.lit.filters[0];
      cont = (count + val.lit.pulseOffset) / val.lit.pulseLength;
      m = pulse.matrix;
      m[0] = Math.abs(Math.sin(cont * 2 * Math.PI)) * 0.5 + 0.5;
      m[5] = Math.abs(Math.sin(cont * 2 * Math.PI)) * 0.5 + 0.5;
      m[10] = Math.abs(Math.sin(cont * 2 * Math.PI)) * 0.5 + 0.5;
      m[15] = Math.abs(Math.sin(cont * 2 * Math.PI)) * 0.25 + 0.75;
      pulse.matrix = m;
    }
    _ref2 = this.goalContainer.children;
    for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
      cont = _ref2[_j];
      if (cont.children.length >= 2 && cont.filters.length >= 2) {
        pulse = cont.filters[1];
        correspondCont = this.colorContainers[cont.children[0].color.toUpperCase()].lit;
        c = (count + correspondCont.pulseOffset) / correspondCont.pulseLength;
        m = pulse.matrix;
        if (parseInt(cont.children[1].text.substring(0, 1)) >= parseInt(cont.children[1].text.substring(2))) {
          m[0] = Math.abs(Math.sin(c * 2 * Math.PI)) * 0.5 + 0.5;
          m[5] = Math.abs(Math.sin(c * 2 * Math.PI)) * 0.5 + 0.5;
          m[10] = Math.abs(Math.sin(c * 2 * Math.PI)) * 0.5 + 0.5;
          m[15] = Math.abs(Math.sin(c * 2 * Math.PI)) * 0.25 + 0.75;
        } else {
          m[0] = 1;
          m[5] = 1;
          m[10] = 1;
          m[15] = 1;
        }
        pulse.matrix = m;
      }
    }
  };


  /* The animation function. Called by pixi and requests to be recalled */

  this.animate = function() {
    var col, connector, core, curLit, goalContainer, h, hLit, inc, isWin, n, nConnector, nS, pan, panel, radTo60Degree, rotSpeed, spr, tolerance, value, _j, _k, _l, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _len8, _len9, _m, _n, _o, _p, _q, _r, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
    window.count += 1;
    this.calcPulseFilter(window.count);
    rotSpeed = 1 / 5;
    tolerance = 0.000001;
    radTo60Degree = 1.04719755;
    if ((this.BOARD != null)) {
      curLit = this.BOARD.crystalLitCount();
      goalContainer = this.menu.children[this.goalContainerIndex];
      isWin = true;
      _ref1 = goalContainer.children;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pan = _ref1[_j];
        _ref2 = pan.children;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          spr = _ref2[_k];
          if (spr instanceof PIXI.Text && spr.color.toUpperCase() in curLit) {
            spr.setText(curLit[spr.color.toUpperCase()] + spr.text.substring(1));
            if (curLit[spr.color.toUpperCase()] < parseInt(spr.text.substring(2))) {
              isWin = false;
            }
          }
        }
      }
      if (isWin && (this.winContainer == null) && this.showWinContainer) {
        this.gameOn = false;
        this.makeWinGameContainer();
      }
      _ref3 = this.BOARD.allHexes();
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        h = _ref3[_l];
        if (h.isLit().length > 0 && !h.backPanel.children[0].lit) {
          h.backPanel.children[0].lit = true;
          if (!(h instanceof Prism)) {
            this.toLit(h.backPanel.spr);
          }
        }
        if (h.isLit().length === 0 && h.backPanel.children[0].lit) {
          h.backPanel.children[0].lit = false;
          if (!(h instanceof Prism)) {
            this.toUnlit(h.backPanel.spr);
          }
        }
        hLit = h.isLit();
        if (h instanceof Prism) {
          _ref4 = h.cores;
          for (col in _ref4) {
            core = _ref4[col];
            if ((_ref5 = col.toLowerCase(), __indexOf.call(hLit, _ref5) < 0) && core.alpha > 0) {
              core.alpha = 0;
            } else if ((_ref6 = col.toLowerCase(), __indexOf.call(hLit, _ref6) >= 0) && core.alpha === 0) {
              core.alpha = 0.75;
            }
          }
        }
        nS = h.getNeighborsWithBlanks();
        _ref7 = h.colorPanels;
        for (col in _ref7) {
          panel = _ref7[col];
          _ref8 = panel.children;
          for (_m = 0, _len4 = _ref8.length; _m < _len4; _m++) {
            connector = _ref8[_m];
            c = h.colorOfSide(connector.side);
            n = nS[connector.side];
            if ((n != null) && __indexOf.call(hLit, c) >= 0 && n.colorOfSide(n.indexLinked(h)) === c && !connector.linked) {
              connector.texture = PIXI.Texture.fromImage(this.siteprefix + "assets/img/connector_on.png");
              this.toLit(connector);
              _ref9 = n.colorPanels;
              for (_n = 0, _len5 = _ref9.length; _n < _len5; _n++) {
                nConnector = _ref9[_n];
                if (nConnector.side === n.indexLinked(h) && !nConnector.linked) {
                  nConnector.texture = PIXI.Texture.fromImage(this.siteprefix + "assets/img/connector_on.png");
                  this.toLit(nConnector);
                }
              }
            } else if (connector.linked && (__indexOf.call(hLit, c) < 0 || (n != null) && n.colorOfSide(n.indexLinked(h)) !== c)) {
              connector.texture = PIXI.Texture.fromImage(this.siteprefix + "assets/img/connector_off.png");
              this.toUnlit(connector);
              if (n != null) {
                _ref10 = n.colorPanels;
                for (_o = 0, _len6 = _ref10.length; _o < _len6; _o++) {
                  nConnector = _ref10[_o];
                  if (nConnector.side === n.indexLinked(h) && nConnector.linked) {
                    nConnector.texture = PIXI.Texture.fromImage(this.siteprefix + "assets/img/connector_off.png");
                    this.toUnlit(nConnector);
                  }
                }
              }
            }
          }
        }

        /* Rotation of a prism - finds a prism that wants to rotate and rotates it a bit.
            If this is the first notification that this prism wants to rotate, stops providing light.
            If the prism is now done rotating, starts providing light again
         */
        if (h instanceof Prism && h.currentRotation !== h.targetRotation) {
          if (h.canLight) {
            h.canLight = false;
            h.light();
          }
          inc = (h.targetRotation - h.prevRotation) >= 0 ? rotSpeed : -rotSpeed;
          h.backPanel.rotation += inc * radTo60Degree;
          h.currentRotation += inc;
          _ref11 = h.colorPanels;
          for (_p = 0, _len7 = _ref11.length; _p < _len7; _p++) {
            value = _ref11[_p];
            value.rotation += inc * radTo60Degree;
          }
          _ref12 = h.cores;
          for (col in _ref12) {
            core = _ref12[col];
            core.currentRotation += inc;
          }
          if (Math.abs(h.targetRotation - h.currentRotation) < tolerance) {
            inc = h.targetRotation - h.currentRotation;
            h.backPanel.rotation += inc * radTo60Degree;
            h.currentRotation += inc;
            _ref13 = h.cores;
            for (col in _ref13) {
              core = _ref13[col];
              core.currentRotation += inc;
            }
            _ref14 = h.colorPanels;
            for (_q = 0, _len8 = _ref14.length; _q < _len8; _q++) {
              value = _ref14[_q];
              value.rotation += inc * radTo60Degree;
              _ref15 = value.children;
              for (_r = 0, _len9 = _ref15.length; _r < _len9; _r++) {
                spr = _ref15[_r];
                spr.side = __modulo(spr.side + (h.currentRotation - h.prevRotation), Hex.SIDES);
              }
            }
            h.prevRotation = h.currentRotation;
            h.canLight = true;
            h.light();
          }
        }

        /* Spark and crystal color changing */
        if ((h instanceof Spark || h instanceof Crystal) && h.toColor !== "") {
          col = !isNaN(h.toColor) ? Color.asString(h.toColor).toUpperCase() : h.toColor.toUpperCase();
          h.backPanel.spr.color = col;
          this.toLit(h.backPanel.spr);
          h.toColor = "";
        }
      }
    }
    requestAnimFrame(animate);
    this.renderer.render(this.stage);
  };


  /* The window resize function. Called whenever the window is resized, and by some other functions after they add elements */

  this.resize = function() {
    var bck, cContainer, col, easyButton, effectiveCount, fixY, fixYRowTwo, goalContainer, hardButton, helpBack, helpButton, helpGoalHighlight, helpGoalText, helpHeight, helpWidth, icon, lvlPush, lvlText, margin, medButton, menuHeight, menumargin, n, newScale2, newScale3, newX, nextLvl, prevLvl, resetButton, scale, title, _ref1, _ref2, _ref3;
    margin = 0;
    window.renderer.resize(window.innerWidth - margin, window.innerHeight - margin);
    newScale2 = Math.min(1, Math.max(0.5, window.innerHeight / 1500));
    newScale3 = newScale2 * 0.5;
    if ((this.menu != null) && this.menu.children.length > 0) {
      bck = this.menu.children[0];
      icon = this.menu.children[1];
      title = this.menu.children[2];
      prevLvl = this.menu.children[3];
      lvlText = this.menu.children[4];
      nextLvl = this.menu.children[5];
      resetButton = this.menu.children[6];
      helpButton = this.menu.children[7];
      easyButton = this.menu.children[8];
      medButton = this.menu.children[9];
      hardButton = this.menu.children[10];
      goalContainer = this.menu.children[this.goalContainerIndex];
      bck.scale.x = Math.max(window.innerWidth / bck.texture.baseTexture.width, 0.75);
      bck.scale.y = Math.max(window.innerHeight / bck.texture.baseTexture.height, 0.75);
      menuHeight = 75;
      this.base.position.y = menuHeight;
      _ref1 = this.colorContainers;
      for (col in _ref1) {
        cContainer = _ref1[col];
        cContainer.position.y = menuHeight;
      }
      menumargin = 20;
      lvlPush = function(n) {
        if (this.level + n >= 10) {
          return 5;
        } else {
          return 0;
        }
      };
      prevLvl.position.x = menumargin;
      lvlText.position.x = prevLvl.position.x + 50 + lvlPush(-1);
      nextLvl.position.x = lvlText.position.x + 75 + lvlPush(0);
      resetButton.position.x = nextLvl.position.x + 60 + lvlPush(1);
      icon.position.x = (window.innerWidth - 125) / 2;
      title.position.x = (window.innerWidth - 50) / 2;
      helpButton.position.x = window.innerWidth - menumargin - 40;
      hardButton.position.x = helpButton.position.x;
      medButton.position.x = hardButton.position.x - 60;
      easyButton.position.x = medButton.position.x - 60;
      fixY = function(comp, scale) {
        comp.position.y = 45 * scale;
      };
      fixY(icon, newScale3);
      icon.position.y -= 4;
      fixY(title, newScale3);
      title.position.y -= 5;
      fixY(lvlText, newScale3);
      fixY(resetButton, newScale3);
      fixY(helpButton, newScale3);
      fixY(nextLvl, newScale3);
      fixY(prevLvl, newScale3);
      fixYRowTwo = function(comp, scale) {
        comp.position.y = 45 * scale + 35;
      };
      fixYRowTwo(easyButton, newScale3);
      fixYRowTwo(medButton, newScale3);
      fixYRowTwo(hardButton, newScale3);
      if (goalContainer != null) {
        goalContainer.position.y = -75;
        goalContainer.position.x = helpButton.position.x - 90 * goalContainer.count;
      }
    }
    if (this.helpContainer != null) {
      helpWidth = this.helpContainer.children[3].getLocalBounds().width * this.helpContainer.children[3].scale.x;
      helpHeight = this.helpContainer.children[3].getLocalBounds().height * this.helpContainer.children[3].scale.y;
      this.helpContainer.position.x = (window.innerWidth - helpWidth) / 2;
      this.helpContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
      helpBack = this.helpContainer.children[0];
      helpBack.position.x = -this.helpContainer.position.x - 15;
      helpBack.position.y = -this.helpContainer.position.y - 15;
      helpBack.height = window.innerHeight + 25;
      helpBack.width = window.innerWidth + 25;
      if (goalContainer != null) {
        helpGoalHighlight = this.helpContainer.children[1];
        helpGoalHighlight.position.y = -this.helpContainer.position.y;
        effectiveCount = Math.max(3, goalContainer.count);
        helpGoalHighlight.scale.x = 90 * effectiveCount / 100;
        helpGoalHighlight.position.x = (helpButton.position.x - 90 * effectiveCount) - this.helpContainer.position.x - helpGoalHighlight.scale.x * 11 - 20;
        helpGoalText = this.helpContainer.children[2];
        helpGoalText.position.y = -this.helpContainer.position.y + 40;
        helpGoalText.position.x = helpGoalHighlight.position.x + 8 + 9 * effectiveCount;
      }
    }
    if (this.winContainer != null) {
      helpWidth = this.winContainer.getLocalBounds().width;
      helpHeight = this.winContainer.getLocalBounds().height;
      this.winContainer.position.x = (window.innerWidth - helpWidth) / 2;
      this.winContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
    }
    if (this.BOARD != null) {
      scale = (1 / 130) * Math.min(window.innerHeight / window.BOARD.getHeight() / 1.1, window.innerWidth * 1.15 / window.BOARD.getWidth());
      this.base.scale.x = scale;
      this.base.scale.y = scale;
      _ref2 = this.colorContainers;
      for (col in _ref2) {
        cContainer = _ref2[col];
        cContainer.scale.x = scale;
        cContainer.scale.y = scale;
      }
      n = this.hexRad * this.base.scale.x;
      newX = (window.innerWidth - window.BOARD.getWidth() * n) / 2 + 20;
      this.base.position.x = newX;
      _ref3 = this.colorContainers;
      for (col in _ref3) {
        cContainer = _ref3[col];
        cContainer.position.x = newX;
      }
    }
  };

}).call(this);
