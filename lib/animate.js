// Generated by CoffeeScript 1.9.3
(function() {
  var checkForWin,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

  this.count = 0;


  /* Lights the hex */

  this.updateLight = function(hex) {
    var colorsLit, connector, i, len, ref, ref1, results;
    if (hex instanceof Crystal) {
      return hex.spr.tint = this.Color.hexValueForLit(hex.lit);
    } else if (hex instanceof Spark) {
      return hex.spr.tint = this.Color.hexValueForLit(hex.isLit()[0]);
    } else if (hex instanceof Prism) {
      colorsLit = hex.isLit();
      ref = hex.connectors;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        connector = ref[i];
        if (ref1 = connector.color.toLowerCase(), indexOf.call(colorsLit, ref1) >= 0) {
          results.push(connector.tint = this.Color.hexValueForLit(connector.color));
        } else {
          results.push(connector.tint = this.Color.hexValueForUnlit(connector.color));
        }
      }
      return results;
    } else {
      throw "Incorrect call to updateLight";
    }
  };

  checkForWin = function() {
    var curLit, goalContainer, i, len, ref, spr;
    curLit = this.BOARD.crystalLitCount();
    goalContainer = this.menu.children[this.goalContainerIndex];
    ref = goalContainer.children;
    for (i = 0, len = ref.length; i < len; i++) {
      spr = ref[i];
      if (spr instanceof PIXI.Text && spr.color.toUpperCase() in curLit) {
        spr.setText(curLit[spr.color.toUpperCase()] + spr.text.substring(1));
        if (curLit[spr.color.toUpperCase()] < parseInt(spr.text.substring(2))) {
          return false;
        }
      }
    }
    return true;
  };


  /* The animation function. Called by pixi and requests to be recalled */

  this.animate = function() {
    var col, curLit, goalContainer, h, i, inc, j, k, l, len, len1, len2, len3, newSides, radTo60Degree, ref, ref1, ref2, ref3, rotSpeed, side, tolerance, value;
    window.count += 1;
    rotSpeed = 1 / 8;
    tolerance = 0.000001;
    radTo60Degree = 1.04719755;
    if ((this.BOARD != null)) {
      curLit = this.BOARD.crystalLitCount();
      goalContainer = this.menu.children[this.goalContainerIndex];
      if (checkForWin() && (this.winContainer == null) && this.showWinContainer) {
        this.gameOn = false;
        this.makeWinGameContainer();
      }
      ref = this.BOARD.allHexes();
      for (i = 0, len = ref.length; i < len; i++) {
        h = ref[i];
        this.updateLight(h);

        /* Rotation of a prism - finds a prism that wants to rotate and rotates it a bit.
            If this is the first notification that this prism wants to rotate, stops providing light.
            If the prism is now done rotating, starts providing light again
         */
        if (h instanceof Prism && h.currentRotation !== h.targetRotation) {
          if (h.canLight) {
            h.canLight = false;
            h.light();
          }
          inc = (h.targetRotation - h.prevRotation) >= 0 ? rotSpeed : -rotSpeed;
          h.backPanel.rotation += inc * radTo60Degree;
          h.currentRotation += inc;
          ref1 = h.connectors;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            value = ref1[j];
            value.rotation += inc * radTo60Degree;
          }
          if (Math.abs(h.targetRotation - h.currentRotation) < tolerance) {
            inc = h.targetRotation - h.currentRotation;
            h.backPanel.rotation += inc * radTo60Degree;
            h.currentRotation += inc;
            ref2 = h.connectors;
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              value = ref2[k];
              value.rotation += inc * radTo60Degree;
              newSides = [];
              ref3 = value.sides;
              for (l = 0, len3 = ref3.length; l < len3; l++) {
                side = ref3[l];
                newSides.push(modulo(side + (h.currentRotation - h.prevRotation), Hex.SIDES));
              }
              value.sides = newSides;
            }
            h.prevRotation = h.currentRotation;
            h.canLight = true;
            h.light();
          }
        }

        /* Spark and crystal color changing */
        if ((h instanceof Spark || h instanceof Crystal) && h.toColor !== "") {
          col = !isNaN(h.toColor) ? Color.asString(h.toColor).toUpperCase() : h.toColor.toUpperCase();
          h.backPanel.spr.color = col;
          this.updateLight(h);
          h.toColor = "";
        }
      }
    }
    requestAnimFrame(animate);
    this.renderer.render(this.stage);
  };


  /* The window resize function. Called whenever the window is resized, and by some other functions after they add elements */

  this.resize = function() {
    var bck, cContainer, col, dumSpr, easyButton, effectiveCount, fixY, fixYRowTwo, goalContainer, hardButton, helpBack, helpButton, helpGoalHighlight, helpGoalText, helpHeight, helpWidth, i, icon, len, lvlPush, lvlText, margin, medButton, menuHeight, menumargin, n, newScale2, newScale3, newX, nextLvl, prevLvl, ref, ref1, ref2, resetButton, scale, subPane, subPaneArr, title;
    margin = 0;
    window.renderer.resize(window.innerWidth - margin, window.innerHeight - margin);
    newScale2 = Math.min(1, Math.max(0.5, window.innerHeight / 1500));
    newScale3 = newScale2 * 0.5;
    if ((this.menu != null) && this.menu.children.length > 0) {
      bck = this.menu.children[0];
      icon = this.menu.children[1];
      title = this.menu.children[2];
      prevLvl = this.menu.children[3];
      lvlText = this.menu.children[4];
      nextLvl = this.menu.children[5];
      resetButton = this.menu.children[6];
      helpButton = this.menu.children[7];
      easyButton = this.menu.children[8];
      medButton = this.menu.children[9];
      hardButton = this.menu.children[10];
      goalContainer = this.menu.children[this.goalContainerIndex];
      bck.scale.x = Math.max(window.innerWidth / bck.texture.baseTexture.width, 0.75);
      bck.scale.y = Math.max(window.innerHeight / bck.texture.baseTexture.height, 0.75);
      menuHeight = 75;
      this.base.position.y = menuHeight;
      ref = this.colorContainers;
      for (col in ref) {
        cContainer = ref[col];
        cContainer.position.y = menuHeight;
      }
      menumargin = 20;
      lvlPush = function(n) {
        if (this.level + n >= 10) {
          return 5;
        } else {
          return 0;
        }
      };
      prevLvl.position.x = menumargin;
      lvlText.position.x = prevLvl.position.x + 50 + lvlPush(-1);
      nextLvl.position.x = lvlText.position.x + 75 + lvlPush(0);
      resetButton.position.x = nextLvl.position.x + 60 + lvlPush(1);
      icon.position.x = (window.innerWidth - 125) / 2;
      title.position.x = (window.innerWidth - 50) / 2;
      helpButton.position.x = window.innerWidth - menumargin - 40;
      hardButton.position.x = helpButton.position.x;
      medButton.position.x = hardButton.position.x - 60;
      easyButton.position.x = medButton.position.x - 60;
      fixY = function(comp, scale) {
        comp.position.y = 45 * scale;
      };
      fixY(icon, newScale3);
      icon.position.y -= 4;
      fixY(title, newScale3);
      title.position.y -= 5;
      fixY(lvlText, newScale3);
      fixY(resetButton, newScale3);
      fixY(helpButton, newScale3);
      fixY(nextLvl, newScale3);
      fixY(prevLvl, newScale3);
      fixYRowTwo = function(comp, scale) {
        comp.position.y = 45 * scale + 35;
      };
      fixYRowTwo(easyButton, newScale3);
      fixYRowTwo(medButton, newScale3);
      fixYRowTwo(hardButton, newScale3);
      if (goalContainer != null) {
        goalContainer.position.y = 25;
        goalContainer.position.x = helpButton.position.x - 90 * goalContainer.count;
      }
    }
    if (this.helpContainer != null) {
      helpWidth = this.helpContainer.children[3].getLocalBounds().width * this.helpContainer.children[3].scale.x;
      helpHeight = this.helpContainer.children[3].getLocalBounds().height * this.helpContainer.children[3].scale.y;
      this.helpContainer.position.x = (window.innerWidth - helpWidth) / 2;
      this.helpContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
      helpBack = this.helpContainer.children[0];
      helpBack.position.x = -this.helpContainer.position.x - 15;
      helpBack.position.y = -this.helpContainer.position.y - 15;
      helpBack.height = window.innerHeight + 25;
      helpBack.width = window.innerWidth + 25;
      if (goalContainer != null) {
        helpGoalHighlight = this.helpContainer.children[1];
        helpGoalHighlight.position.y = -this.helpContainer.position.y;
        effectiveCount = Math.max(3, goalContainer.count);
        helpGoalHighlight.scale.x = 90 * effectiveCount / 100;
        helpGoalHighlight.position.x = (helpButton.position.x - 90 * effectiveCount) - this.helpContainer.position.x - helpGoalHighlight.scale.x * 11 - 20;
        helpGoalText = this.helpContainer.children[2];
        helpGoalText.position.y = -this.helpContainer.position.y + 40;
        helpGoalText.position.x = helpGoalHighlight.position.x + 8 + 9 * effectiveCount;
      }
    }
    if (this.winContainer != null) {
      helpWidth = this.winContainer.getLocalBounds().width;
      helpHeight = this.winContainer.getLocalBounds().height;
      this.winContainer.position.x = (window.innerWidth - helpWidth) / 2;
      this.winContainer.position.y = (window.innerHeight - menuHeight - helpHeight) / 2 + menuHeight;
    }
    if (this.BOARD != null) {
      scale = (1 / 130) * Math.min((window.innerHeight - menuHeight) / window.BOARD.getHeight(), window.innerWidth * 1.15 / window.BOARD.getWidth());
      this.base.scale.x = scale;
      this.base.scale.y = scale;
      ref1 = this.colorContainers;
      for (col in ref1) {
        cContainer = ref1[col];
        cContainer.scale.x = scale;
        cContainer.scale.y = scale;
      }
      n = this.hexRad * this.base.scale.x;
      newX = (window.innerWidth - window.BOARD.getWidth() * n) / 2 + 20;
      this.base.position.x = newX;
      ref2 = this.colorContainers;
      for (col in ref2) {
        cContainer = ref2[col];
        cContainer.position.x = newX;
        subPaneArr = [cContainer.lit, cContainer.unlit];
        for (i = 0, len = subPaneArr.length; i < len; i++) {
          subPane = subPaneArr[i];
          dumSpr = subPane.children[0];
          dumSpr.position.x = -cContainer.position.x;
          dumSpr.position.y = -cContainer.position.y;
          dumSpr.height = (window.innerHeight + menuHeight) / scale;
          dumSpr.width = window.innerWidth;
        }
      }
    }
  };

}).call(this);
