// Generated by CoffeeScript 1.9.3
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    modulo = function(a, b) { return (+a % (b = +b) + b) % b; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  this.Color = (function() {
    function Color() {}

    Color._val = {
      NONE: 0,
      ANY: 1,
      RED: 2,
      BLUE: 3,
      GREEN: 4,
      ORANGE: 5,
      PURPLE: 6,
      CYAN: 7,
      YELLOW: 8,
      PINK: 9
    };

    Color.NONE = Color._val.NONE;

    Color.ANY = Color._val.ANY;

    Color.RED = Color._val.RED;

    Color.BLUE = Color._val.BLUE;

    Color.GREEN = Color._val.GREEN;

    Color.ORANGE = Color._val.ORANGE;

    Color.PURPLE = Color._val.PURPLE;

    Color.CYAN = Color._val.CYAN;

    Color.YELLOW = Color._val.YELLOW;

    Color.PINK = Color._val.PINK;

    Color.SPECIAL_OFFSET = 2;

    Color.filters = {};

    Color.count = function() {
      return Object.keys(this._val).length;
    };

    Color.values = function() {
      return Object.keys(this._val);
    };


    /* Returns a subArray of REGULAR colors, starting at color n and giving l colors. Caps at the available number of regular colors */

    Color.subValues = function(n) {
      var c, len;
      c = Color.count();
      len = Math.min(n, c - this.SPECIAL_OFFSET);
      return Color.values().splice(this.SPECIAL_OFFSET, len);
    };


    /* Returns the regular colors */

    Color.regularColors = function() {
      return this.subValues(Number.MAX_VALUE);
    };

    Color.isRegularColor = function(c) {
      var ref, ref1;
      if (isNaN(c)) {
        return ref = c.toUpperCase(), indexOf.call(this.regularColors(), ref) >= 0;
      } else {
        return ref1 = Color.asString(c).toUpperCase(), indexOf.call(this.regularColors(), ref1) >= 0;
      }
    };


    /* Returns an array of length length filled with color col */

    Color.fill = function(length, col) {
      var i, j, ref, results;
      results = [];
      for (i = j = 0, ref = length - 1; j < ref; i = j += 1) {
        results.push(col);
      }
      return results;
    };


    /* Returns a hex value for a lit color. Unused for the time being */

    Color.hexValueForLit = function(color) {
      var c;
      c = isNaN(color) ? this.fromString(color) : color;
      switch (c) {
        case this.RED:
          return 0xFF3300;
        case this.BLUE:
          return 0x3399FF;
        case this.GREEN:
          return 0x66FF66;
        case this.ORANGE:
          return 0xFF9900;
        case this.PURPLE:
          return 0x9966FF;
        case this.CYAN:
          return 0x66FFFF;
        case this.YELLOW:
          return 0xFFFF66;
        case this.PINK:
          return 0xFF66CC;
        default:
          return 0xCCCCCC;
      }
    };


    /* Returns a hex value for an unlit color. Unused for the time being */

    Color.hexValueForUnlit = function(color) {
      var c;
      c = isNaN(color) ? this.fromString(color) : color;
      switch (c) {
        case this.RED:
          return 0x801A00;
        case this.BLUE:
          return 0x1F5C99;
        case this.GREEN:
          return 0x3D993D;
        case this.ORANGE:
          return 0x804C00;
        case this.PURPLE:
          return 0x4C3380;
        case this.CYAN:
          return 0x3D9999;
        case this.YELLOW:
          return 0x99993D;
        case this.PINK:
          return 0xB2478F;
        default:
          return 0xCCCCCC;
      }
    };

    Color.asString = function(color) {
      switch (color) {
        case this.ANY:
          return "any";
        case this.RED:
          return "red";
        case this.BLUE:
          return "blue";
        case this.GREEN:
          return "green";
        case this.ORANGE:
          return "orange";
        case this.PURPLE:
          return "purple";
        case this.CYAN:
          return "cyan";
        case this.YELLOW:
          return "yellow";
        case this.PINK:
          return "pink";
        default:
          return "none";
      }
    };

    Color.fromString = function(color) {
      if (color != null) {
        switch (color.toLowerCase()) {
          case "any":
            return this.ANY;
          case "red":
            return this.RED;
          case "blue":
            return this.BLUE;
          case "green":
            return this.GREEN;
          case "orange":
            return this.ORANGE;
          case "purple":
            return this.PURPLE;
          case "cyan":
            return this.CYAN;
          case "yellow":
            return this.YELLOW;
          case "pink":
            return this.PINK;
          default:
            return this.NONE;
        }
      } else {
        return this.NONE;
      }
    };

    return Color;

  })();

  this.ColorCircle = (function() {

    /* Creates a circularly linked list of colorCircles from an array of colors.
        Returns the first colorCircle (head). Returns null if the input is null or length 0
     */
    ColorCircle.fromArray = function(colors) {
      var c, cc, i, j, l, ref, t;
      if (colors === null || colors.length === 0) {
        return null;
      }
      l = colors.length;
      t = (function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = colors.length; j < len1; j++) {
          c = colors[j];
          results.push(new ColorCircle(c, null, null));
        }
        return results;
      })();
      for (i = j = 0, ref = l - 1; j <= ref; i = j += 1) {
        cc = t[i];
        cc.size = l;
        cc.prev = t[modulo(i - 1, l)];
        cc.next = t[modulo(i + 1, l)];
      }
      return t[0];
    };


    /* Returns a random color array of a given length. Uses at most maxColors (or 6 if maxColors > 6) colors, never uses NONE.
        throws IllegalArgumentException if length <= 0 or maxColors <= 0
     */

    ColorCircle.randomArray = function(length, maxColors) {
      var a, i, m;
      if (length <= 0) {
        throw "Can't make Color Array of length " + length + " for color circle";
      }
      if (maxColors <= 0) {
        throw "Can't make Color Array of length using at most " + maxColors + " colors";
      }
      m = Math.min(maxColors, Color.regularColors().length);
      a = (function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = length - 1; j <= ref; i = j += 1) {
          results.push(Color.regularColors()[Math.floor(Math.random() * m)]);
        }
        return results;
      })();
      return a;
    };


    /* Constructs a color circle with the given inputs. Should not be used outside of this file - use helpers */

    function ColorCircle(col, prev, next) {
      this.color = col;
      this.prev = prev;
      this.next = next;
      this.size = 0;
    }


    /* Returns the color of this link */

    ColorCircle.prototype.getColor = function() {
      return this.color;
    };


    /* Returns the next link */

    ColorCircle.prototype.getNext = function() {
      return this.next;
    };


    /* Returns the previous link */

    ColorCircle.prototype.getPrevious = function() {
      return this.prev;
    };


    /* Returns the size of this circle */

    ColorCircle.prototype.getSize = function() {
      return this.size;
    };


    /* Converts this to an array of colors */

    ColorCircle.prototype.toArray = function() {
      var a, arr;
      arr = [];
      a = this;
      while (true) {
        arr.push(a.color);
        a = a.next;
        if (a === this) {
          break;
        }
      }
      return arr;
    };


    /* Returns a string representation of the colorCircle starting with this */

    ColorCircle.prototype.toString = function() {
      return this.toArray.toString();
    };


    /* Two color circles are equal if their sizes are equald and they have the same color at every position */

    ColorCircle.prototype.equals = function(o) {
      var c, d;
      if (!(o instanceof ColorCircle)) {
        return false;
      }
      c = o;
      d = this;
      if (this.size !== c.size) {
        return false;
      }
      while (true) {
        if (c.color !== d.color) {
          return false;
        }
        c = c.next;
        d = d.next;
        if (d === this) {
          break;
        }
      }
      return true;
    };


    /* Two color circles match if their sizes are equald and they have the same color at every position, with Color.ANY as a wild card */

    ColorCircle.prototype.matches = function(o) {
      var c, d;
      if (!(o instanceof ColorCircle)) {
        return false;
      }
      c = o;
      d = this;
      if (this.size !== c.size) {
        return false;
      }
      while (true) {
        if (c.color !== d.color && Color.fromString(c.color) !== Color.ANY && Color.fromString(d.color) !== Color.ANY) {
          return false;
        }
        c = c.next;
        d = d.next;
        if (d === this) {
          break;
        }
      }
      return true;
    };

    return ColorCircle;

  })();


  /*A simple location class - nice int tuple.
   Using this over the Point class because constantly shifting from (x,y) to (col,row) is confusing
   */

  this.Loc = (function() {
    function Loc(row, col) {
      this.row = row;
      this.col = col;
      this.prev = null;
      this.dist = Number.MAX_VALUE;
    }


    /* Resets the fields used by A* */

    Loc.prototype.reset = function() {
      this.prev = null;
      return this.dist = Number.MAX_VALUE;
    };


    /* Returns true if this is OOB. Row or col < 0 or greater than resepctive max */

    Loc.prototype.isOOB = function(maxR, maxC) {
      return this.row < 0 || this.col < 0 || this.row > maxR || this.col > maxC;
    };


    /* Returns a object representing this location in cube coordinates -> (x,y,z). */

    Loc.prototype.cubeCoordinates = function() {
      var o, x, y, z;
      x = this.col;
      z = this.row - (this.col - (this.col & 1)) / 2;
      y = -x - z;
      o = {};
      o[x] = x;
      o[y] = y;
      o[z] = z;
      return o;
    };


    /* Returns the distance from this to dest using the cube coordinate distance */

    Loc.prototype.distance = function(dest) {
      var c1, c2;
      c1 = this.cubeCoordinates();
      c2 = dest.cubeCoordinates();
      return (Math.abs(c1.x - c2.x) + Math.abs(c1.y - c2.y) + Math.abs(c1.z - c2.z)) / 2;
    };


    /* Returns true if this is adjacent to l, false otherwise */

    Loc.prototype.isAdjacentTo = function(l) {
      var j, len1, ref, vec;
      ref = Hex.NEIGHBOR_COORDINATES[modulo(this.col, 2)];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        vec = ref[j];
        if (l.row === this.row + vec.row && l.col === this.col + vec.col) {
          return true;
        }
      }
      return false;
    };

    Loc.prototype.equals = function(o) {
      var l;
      if (!o instanceof Loc) {
        return false;
      } else {
        l = Loc(o);
        return this.row === l.row && this.col === l.col;
      }
    };

    Loc.prototype.toString = function() {
      return "(" + this.row + "," + this.col + ")";
    };


    /* Returns true if the string is a location, false otherwise */

    Loc.isLoc = function(s) {
      var c, i, o, s1, s2;
      i = s.indexOf(",");
      o = s.indexOf("(");
      c = s.indexOf(")");
      if (i === -1 || o !== 0 || c !== (s.length - 1)) {
        return false;
      }
      s1 = s.substring(1, i);
      s2 = s.substring(i + 1, s.length - 1);
      return !(isNaN(s1) || isNaN(s2));
    };

    Loc.fromString = function(s) {
      var i, s1, s2;
      i = s.indexOf(",");
      s1 = s.substring(1, i);
      s2 = s.substring(i + 1, s.length - 1);
      return new Loc(parseInt(s1), parseInt(s2));
    };


    /* Returns a new Location that represents a vector from l1 to l2 */

    Loc.vec = function(l1, l2) {
      return new Loc(l2.row - l1.row, l2.col - l1.col);
    };


    /* Constructs a new Random location in the range [0 ... maxR), [0 ... maxC */

    Loc.random = function(maxR, maxC) {
      return new Loc(Math.floor(Math.random() * maxR), Math.floor(Math.random() * maxC));
    };

    Loc.NOWHERE = new Loc(-9999, -9999);

    return Loc;

  })();

  this.Board = (function() {

    /* Constructor for an empty board of size rs*cs */
    function Board(rs, cs) {
      var c, j, p, r, ref, ref1;
      if (rs < 0 || cs < 0) {
        throw "Illegal Board Construction for Dimensions " + rs + ", " + cs;
      }
      this.height = rs;
      this.width = cs;
      this.board = [];
      for (r = j = 0, ref = rs - 1; j <= ref; r = j += 1) {
        this.board.push([]);
        for (c = p = 0, ref1 = cs - 1; p <= ref1; c = p += 1) {
          this.board[r].push(null);
        }
      }
      this.allHexesByClass = {};
      this.game = null;
      this.moves = 0;
    }


    /* Returns the height of this board */

    Board.prototype.getHeight = function() {
      return this.height;
    };


    /* Returns the width of this board */

    Board.prototype.getWidth = function() {
      return this.width;
    };


    /* Returns the game this board belongs to (if any) */

    Board.prototype.getGame = function() {
      return this.game;
    };


    /* Sets the game this board belongs to. Throws a runtime exception if game is already set */

    Board.prototype.setGame = function(g) {
      if (this.game !== null) {
        throw "Can't set Game of " + this + " to " + g + " because it is already " + game;
      }
      this.game = g;
    };


    /* Gets rid of this board - signifies that it is no longer used */

    Board.prototype.dispose = function() {
      this.game = null;
      this.board = null;
    };


    /* Returns the index (0 ... Hex.SIDES - 1) of the side of h1 that is facing h2. 
        Returns -1 if either are null or are not neighbors
     */

    Board.prototype.indexLinked = function(h1, h2) {
      var h1Neighbors, i, j, ref;
      if (h1 === null || h2 === null) {
        return -1;
      }
      h1Neighbors = h1.getNeighborsWithBlanks();
      for (i = j = 0, ref = Hex.SIDES; j <= ref; i = j += 1) {
        if (h2 === h1Neighbors[i]) {
          return i;
        }
      }
      return -1;
    };


    /* Returns the color that links h1 and h2. 
        1) The two hexes are neighbors (both non-null), otherwise returns none
        2) The colors of the adjacent sides are the same. Treats Color.any as a wild card.
        If one is color.any and the other isn't, returns the more specific one.
     */

    Board.prototype.colorLinked = function(h1, h2) {
      var c1, c2, index;
      index = this.indexLinked(h1, h2);
      if (index === -1) {
        return Color.NONE;
      }
      c1 = h1.colorOfSide(index);
      c2 = h2.colorOfSide(modulo(index + Hex.SIDES / 2, Hex.SIDES));
      if (c1 === Color.ANY && c2 === Color.ANY) {
        return Color.ANY;
      } else if (c1 === Color.ANY) {
        return c2;
      } else if (c2 === Color.ANY) {
        return c1;
      } else if (c1 === c2) {
        return c1;
      } else {
        return Color.NONE;
      }
    };


    /* Returns the hex at the given location */

    Board.prototype.getHex = function(loc) {
      var e;
      try {
        return this.board[loc.row][loc.col];
      } catch (_error) {
        e = _error;
        loc = Loc.fromString(loc);
        return this.board[loc.row][loc.col];
      }
    };


    /* Returns a flattened version of the board - all hexes in no particular order */

    Board.prototype.allHexes = function() {
      var arr, h, j, key, len1, ref, value;
      arr = [];
      ref = this.allHexesByClass;
      for (key in ref) {
        value = ref[key];
        for (j = 0, len1 = value.length; j < len1; j++) {
          h = value[j];
          arr.push(h);
        }
      }
      return arr;
    };


    /* Returns all hexes in the board that are of a particular class. Returns an empty array if no such class */

    Board.prototype.allHexesOfClass = function(cl) {
      var key, ref, value;
      ref = this.allHexesByClass;
      for (key in ref) {
        value = ref[key];
        if (key.toLowerCase() === cl.toLowerCase()) {
          return value;
        }
      }
      return [];
    };


    /* Returns the colors present on this board, looking at the sparks. Only includes regular colors */

    Board.prototype.colorsPresent = function() {
      var arr, c, j, len1, len2, p, ref, ref1, spark;
      arr = [];
      ref = this.allHexesOfClass("Spark");
      for (j = 0, len1 = ref.length; j < len1; j++) {
        spark = ref[j];
        ref1 = spark.getAvailableColors();
        for (p = 0, len2 = ref1.length; p < len2; p++) {
          c = ref1[p];
          if (indexOf.call(arr, c) < 0 && Color.isRegularColor(c)) {
            arr.push(c);
          }
        }
      }
      return arr;
    };


    /* Returns a map of color -> int that is the sides of prisms that are the color */

    Board.prototype.colorCount = function() {
      var c, j, len1, len2, o, p, prism, ref, ref1;
      o = {};
      ref = this.allHexesOfClass("Prism");
      for (j = 0, len1 = ref.length; j < len1; j++) {
        prism = ref[j];
        ref1 = Color.values();
        for (p = 0, len2 = ref1.length; p < len2; p++) {
          c = ref1[p];
          if (!(c in o)) {
            o[c] = prism.colorCount(c);
          } else {
            o[c] = o[c] + prism.colorCount(c);
          }
        }
      }
      return o;
    };


    /* Returns a map of color -> int that is the number of crystals that are currently lit that color */

    Board.prototype.crystalLitCount = function() {
      var c, cr, crystals, j, len1, len2, lit, o, p, ref;
      o = {};
      crystals = this.allHexesOfClass("Crystal");
      ref = Color.regularColors();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        c = ref[j];
        if (!isNaN(c)) {
          c = Color.asString(c).toUpperCase();
        } else {
          c = c.toUpperCase();
        }
        o[c] = 0;
        for (p = 0, len2 = crystals.length; p < len2; p++) {
          cr = crystals[p];
          lit = (cr != null) && (cr.lit != null) ? !isNaN(cr.lit) ? Color.asString(cr.lit).toUpperCase() : cr.lit.toUpperCase() : Color.asString(Color.NONE);
          if (lit === c) {
            o[c]++;
          }
        }
      }
      return o;
    };


    /* Returns all prisms that have at least one side with color.ANY on it. Useful for finding part of the board not finished */

    Board.prototype.allPrismsWithAny = function() {
      var j, len1, prism, ref, results;
      ref = allHexesOfClass("Prism");
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        prism = ref[j];
        if (prism.colorCount(Color.ANY) >= 1) {
          results.push(prism);
        } else {

        }
      }
      return results;
    };


    /* Sets the hex at position (r,c). Also sets all neighbor hexes as needing a neighbor update.
        Hex must have this as its board. Used in hex construciton, not much elsewhere
     */

    Board.prototype.setHex = function(h, l) {
      var cl, j, len1, n, ref;
      if (h.board !== this) {
        throw "Can't put hex belonging to " + h.board + " in board " + this;
      }
      this.board[l.row][l.col] = h;
      cl = h instanceof Prism ? "Prism" : h instanceof Spark ? "Spark" : h instanceof Crystal ? "Crystal" : "Unknown";
      if (!(cl in this.allHexesByClass)) {
        this.allHexesByClass[cl] = [];
      }
      this.allHexesByClass[cl].push(h);
      ref = h.getNeighbors();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        n = ref[j];
        n.neighborsUpdated = true;
      }
    };


    /* Re-calculates light on whole board - tells each spark to light itself and give light out.
       This should hit the whole board.
     */

    Board.prototype.relight = function() {
      var h, j, len1, len2, p, ref, ref1;
      ref = this.allHexes();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        h = ref[j];
        h.lighters = {};
      }
      ref1 = this.allHexesOfClass("Spark");
      for (p = 0, len2 = ref1.length; p < len2; p++) {
        h = ref1[p];
        h.light();
      }
    };


    /* Two boards are equal if they have the same board */

    Board.prototype.equals = function(o) {
      var b;
      if (!(o instanceof Board)) {
        return false;
      }
      b = Board(o);
      return b.board === this.board;
    };


    /* Returns a string representation of this board as an ascii matrix */

    Board.prototype.toString = function() {
      var el, j, len1, len2, len3, p, q, r, ref, s;
      s = "";
      ref = this.board;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        r = ref[j];
        for (p = 0, len2 = r.length; p < len2; p++) {
          el = r[p];
          if (el === null) {
            s = s + "   |";
          } else if (el instanceof Prism) {
            s = s + " p |";
          } else if (el instanceof Spark) {
            s = s + " s |";
          } else {
            s = s + " c |";
          }
        }
        s = s + "\n";
        for (q = 0, len3 = r.length; q < len3; q++) {
          el = r[q];
          s = s + "----";
        }
        s = s + "\n";
      }
      return s;
    };


    /* Loads the given board from JSON text. Takes the name of the board (no file extension) as arg */

    Board.loadBoard = function(name) {
      var file;
      file = window.siteprefix + "assets/boards/" + name + ".json";
      window.level = parseInt(name.substring(5));
      $.getJSON(file, function(content) {
        var b, key, value;
        console.log("Got board");
        b = new Board(content.Height, content.Width);
        for (key in content) {
          value = content[key];
          if (Loc.isLoc(key)) {
            if (value.Type === "C") {
              new Crystal(b, Loc.fromString(key));
            } else if (value.Type === "P") {
              new Prism(b, Loc.fromString(key), value.Colors);
            } else if (value.Type === "S") {
              new Spark(b, Loc.fromString(key), value.Colors);
            } else {
              Console.error("Bad k/v found " + key + ";" + value);
            }
          } else {
            b[key] = value;
          }
        }
        console.log("Board loaded");
        window.BOARD = b;
        window.onBoardLoad();
      });
    };


    /* Makes a random board with the given dimentions. Mainly for testing. Sparks/Crystals at corners, prisms otw */

    Board.makeBoard = function(rs, cs, cls) {
      var b, c, j, p, r, ref, ref1;
      b = new Board(rs, cs);
      for (r = j = 0, ref = rs - 1; j <= ref; r = j += 1) {
        for (c = p = 0, ref1 = cs - 1; p <= ref1; c = p += 1) {
          if (r === 0 && c === 0 || r === (rs - 1) && c === 0) {
            new Spark(b, new Loc(r, c), Color.subValues(cls));
          } else if (r === 0 && c === (cs - 1) || r === (rs - 1) && c === (cs - 1)) {
            new Crystal(b, new Loc(r, c));
          } else {
            new Prism(b, new Loc(r, c), ColorCircle.randomArray(Hex.SIDES, cls));
          }
        }
      }
      return b;
    };

    Board.anyBoard = function(rs, cs) {
      var b, c, j, p, r, ref, ref1;
      b = new Board(rs, cs);
      for (r = j = 0, ref = rs - 1; j <= ref; r = j += 1) {
        for (c = p = 0, ref1 = cs - 1; p <= ref1; c = p += 1) {
          new Prism(b, new Loc(r, c), Color.fill(Hex.SIDES, Color.ANY));
        }
      }
      return b;
    };


    /* TODO: ALGORITHM STUFF. */

    return Board;

  })();

  this.Game = (function() {
    function Game() {}

    Game._difficulty = {
      EASY: 0,
      MEDIUM: 1,
      HARD: 2
    };

    Game.difficultyCount = function() {
      return Object.keys(this._difficulty).length;
    };

    Game.difficultyValues = function() {
      return Object.keys(this._difficulty);
    };

    Game.EASY = Game._difficulty.EASY;

    Game.MEDIUM = Game._difficulty.MEDIUM;

    Game.HARD = Game._difficulty.HARD;

    Game.asString = function(difficulty) {
      switch (difficulty) {
        case this.EASY:
          return "easy";
        case this.MEDIUM:
          return "medium";
        case this.HARD:
          return "hard";
        default:
          return "NO SUCH DIFFICULTY";
      }
    };

    return Game;

  })();


  /* Abstract parent of all tiles */

  this.Hex = (function() {
    Hex.SIDES = 6;

    Hex.NEIGHBOR_COORDINATES = [[new Loc(-1, 0), new Loc(-1, 1), new Loc(0, 1), new Loc(1, 0), new Loc(0, -1), new Loc(-1, -1)], [new Loc(-1, 0), new Loc(0, 1), new Loc(1, 1), new Loc(1, 0), new Loc(1, -1), new Loc(0, -1)]];


    /* Stuff for communicating with swing version, reading/writing boards */

    Hex.TYPE_KEY = "\"Type\"";

    Hex.LOCATION_KEY = "\"Loc\"";

    Hex.COLORS_KEY = "\"Colors\"";


    /*Stores Board b and Point p as board and location in this hex.
       Throws IllegalArgumentException if b is null, point p is already occupied on board b,
       Or if the location is out of bounds.
     */

    function Hex(board, loc) {
      var a, vec;
      try {
        if (board === null) {
          throw "Can't put hex into null board";
        }
        if (board.getHex(loc) !== null) {
          throw "Board " + board + " already has hex at position " + "(" + loc.row + "," + loc.col + "), can't construct new hex there.";
        }
      } catch (_error) {
        a = _error;
        throw "Can't construct hex in " + board.toString + " at " + loc + ": " + a.message;
      }
      this.board = board;
      this.loc = loc;
      this.neighbors = (function() {
        var j, len1, ref, results;
        ref = Hex.NEIGHBOR_COORDINATES[modulo(loc.col, 2)];
        results = [];
        for (j = 0, len1 = ref.length; j < len1; j++) {
          vec = ref[j];
          results.push(new Loc(loc.row + vec.row, loc.col + vec.col));
        }
        return results;
      })();
      this.neighborsUpdated = true;
      this.neighborHexes = [];
      this.board.setHex(this, loc);
      this.canLight = true;
      this.lighters = {};
      this.lightChange = false;
    }


    /*Returns the neighbors of this hex, clockwise from above. Will always return an array of lenght SIDES,
       but may contain nulls.
       Spots that this does not have a neighbor (off the board) are stored as null.
       Part of lazy calculation of neighborHexes - only updates if neighborsUpdated is true.
       Otherwise returns the (already calculated) neighborHexes
     */

    Hex.prototype.getNeighborsWithBlanks = function() {
      var e, l;
      if (this.neighborsUpdated) {
        this.neighborHexes = (function() {
          var j, len1, ref, results;
          ref = this.neighbors;
          results = [];
          for (j = 0, len1 = ref.length; j < len1; j++) {
            l = ref[j];
            try {
              results.push(this.board.getHex(l));
            } catch (_error) {
              e = _error;
              results.push(null);
            }
          }
          return results;
        }).call(this);
        this.neighborsUpdated = false;
        return this.neighborHexes;
      } else {
        return this.neighborHexes;
      }
    };


    /*Returns the neighbors of this hex, clockwise from above, with nulls removed. 
       Thus no null elements, but resulting array has length 0 <= x <= SIDES
     */

    Hex.prototype.getNeighbors = function() {
      var a, h, j, len1, results;
      a = this.getNeighborsWithBlanks();
      results = [];
      for (j = 0, len1 = a.length; j < len1; j++) {
        h = a[j];
        if (h !== void 0 && h !== null) {
          results.push(h);
        } else {

        }
      }
      return results;
    };

    Hex.prototype.indexLinked = function(h) {
      return this.board.indexLinked(this, h);
    };

    Hex.prototype.colorLinked = function(h) {
      return this.board.colorLinked(this, h);
    };


    /* Looks at all neighbors, and finds a list of neighbors that could be usefully powered by this were they rotated.
        This requires the neighbor to have at least two of color C on it, and that this has the correct color facing that neighbor.
        Shouldn't check if anything requiring this to rotate.
        Also doesn't return any neighbors that are part of this' lighter set.
       
        Only returns prisms.
     
      Does not actually rotate any hexes or modify the board in any way.
     */

    Hex.prototype.children = function(c) {
      var j, len1, n, ref, results;
      ref = getNeighbors();
      results = [];
      for (j = 0, len1 = ref.length; j < len1; j++) {
        n = ref[j];
        if (indexOf.call(lighterSet(c), n) < 0 && n instanceof Prism && h.asPrism().colorCount(c) >= 2 && c === colorOfSide(indexLinked(n))) {
          results.push(n);
        } else {

        }
      }
      return results;
    };


    /*Turns this hex on or off. Turning it off means it doesn't participate in lighting (provide or take). */

    Hex.prototype.turn = function(state) {
      this.canLight = state;
    };


    /* Returns the colors this is lit. Returns empty if this isn't lit */

    Hex.prototype.isLit = function() {
      var key, ref, results, val;
      ref = this.lighters;
      results = [];
      for (key in ref) {
        val = ref[key];
        results.push(val);
      }
      return results;
    };


    /* Returns the hex that is currently directly providing this with light. Returns null if no such hex for color c */

    Hex.prototype.lighter = function(c) {
      var key, ref, val;
      ref = this.lighters;
      for (key in ref) {
        val = ref[key];
        if (val === c) {
          return this.board.getHex(Loc.fromString(key));
        }
      }
      return null;
    };


    /* Returns a set of locations (hexes) that all eventually provide light to this of a given color.
        Can be used to prevent cycles from forming.
     */

    Hex.prototype.lighterSet = function(c) {
      var arr, j, k, key, len1, ref, ref1, val;
      arr = [];
      ref = this.lighters;
      for (key in ref) {
        val = ref[key];
        if (val === c) {
          arr.push(key);
          ref1 = this.board.getHex(Loc.fromString(key)).lighterSet(c);
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            k = ref1[j];
            arr.push(k);
          }
        } else {

        }
      }
      return arr;
    };


    /* Fixes light for this hex. Must be implemented in subclasses. */

    Hex.prototype.light = function() {
      throw "Cannot instantiate Hex Class - light method must be overriden";
    };


    /* Helper method for use in light implementations. Removes lighters that can't light this anymore from lighters map
        Returns true if at least one lighter was removed, false otherwise
     */

    Hex.prototype.pruneLighters = function() {
      var c, h, j, l, len1, oldArr, val, y;
      oldArr = (function() {
        var ref, results;
        ref = this.lighters;
        results = [];
        for (y in ref) {
          val = ref[y];
          results.push(y);
        }
        return results;
      }).call(this);
      for (j = 0, len1 = oldArr.length; j < len1; j++) {
        l = oldArr[j];
        h = this.board.getHex(l);
        c = this.colorLinked(h);
        if (!isNaN(c)) {
          c = Color.asString(c);
        }
        if ((!h.canLight) || c === Color.asString(Color.NONE) || indexOf.call(h.isLit(), c) < 0 || indexOf.call(h.lighterSet(c), this) >= 0) {
          delete this.lighters[l];
        }
      }
      return oldArr.length !== Object.keys(this.lighters).length;
    };


    /* Helper method for use in findLight implementations. Tells neighbors this is currently lighting to look elsewhere */

    Hex.prototype.stopProvidingLight = function() {
      var c, cond1, cond2, cond3, cond4, h, i, j, len1, p, ref, ref1, ref2;
      c = this.isLit();
      for (i = j = 0, ref = c.length - 1; j <= ref; i = j += 1) {
        if (!isNaN(c[i])) {
          c[i] = Color.asString(c);
        }
      }
      ref1 = this.getNeighbors();
      for (p = 0, len1 = ref1.length; p < len1; p++) {
        h = ref1[p];
        cond1 = this.loc in h.lighters;
        cond2 = (ref2 = h.lighters[this.loc], indexOf.call(c, ref2) < 0);
        cond3 = this.colorLinked(h) !== h.lighters[this.loc];
        cond4 = !h.canLight;
        if (cond1 && (cond2 || cond3 || cond4)) {
          h.light();
        }
      }
    };


    /* Helper method for use in findLight implementations. Tells neighbors that this is now lit, 
       maybe get light from this, if not already or this getting light from that.
       If this isn't lit, do nothing. 
       
       Note: Always try to provide light to crystal, never try to provide light to spark. Neither of these recurse, so no trouble.
       Sparks can always provide light, others can only provide light if they have a lighter
     */

    Hex.prototype.provideLight = function() {
      var c, h, hLit, j, len1, lit, ref;
      if (this.canLight && (this instanceof Spark || (Object.keys(this.lighters).length > 0))) {
        lit = this.isLit();
        ref = this.getNeighbors();
        for (j = 0, len1 = ref.length; j < len1; j++) {
          h = ref[j];
          hLit = h.isLit();
          c = this.colorLinked(h);
          if (!isNaN(c)) {
            c = Color.asString(c);
          }
          if (!(h instanceof Spark && lit.length === 0) && ((h instanceof Crystal && hLit.length === 0) || (h instanceof Prism && indexOf.call(lit, c) >= 0 && indexOf.call(hLit, c) < 0))) {
            h.light();
          }
        }
      }
    };


    /* Helper method for use in findLight implementations. Tries to find light among neighbors.
        If a link is found, sets that neighbor as lighter. If no link found, sets lighter to null.
        Only looks for preferred. If preferred is NONE, takes any color. Doesn't take the same color twice.
     */

    Hex.prototype.findLightProviders = function(preferred) {
      var c, h, hLit, j, len1, ref;
      ref = this.getNeighbors();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        h = ref[j];
        hLit = h.isLit();
        c = this.colorLinked(h);
        if (!isNaN(c)) {
          c = Color.asString(c);
        }
        if (h.canLight && indexOf.call(hLit, c) >= 0 && (preferred === Color.NONE || preferred === c) && indexOf.call(this.isLit(), c) < 0 && ((h.lighterSet(c) == null) || indexOf.call(h.lighterSet(c), this) < 0)) {
          this.lighters[h.loc.toString()] = c;
        }
      }
    };


    /* Returns the color of side n of this hex (where side 0 is the top).
       IllegalArgumentException if n < 0, n > SIDES - 1
     */

    Hex.prototype.colorOfSide = function(n) {
      return "Cannot instantiate Hex Class - colorOfSide method must be overriden";
    };


    /* Perform default behavior for interacting with this hex */

    Hex.prototype.click = function() {
      return "Cannot instantiate Hex Class - click method must be overriden";
    };

    Hex.prototype.anticlick = function() {
      return "Cannot instantiate Hex Class - click method must be overriden";
    };


    /* Returns the location of this hex as the string for this hex */

    Hex.prototype.toString = function() {
      return this.loc.toString();
    };


    /* Two hexes are equal if their boards and their locations are the same */

    Hex.prototype.equals = function(o) {
      var h;
      if (!(o instanceof Hex)) {
        return false;
      } else {
        h = Hex(o);
        return this.board === h.board && this.location === h.location;
      }
    };


    /* Signifies that this has been changed; tells the game (if any) to update this as necessary. */

    Hex.prototype.update = function() {
      if ((this.board !== null) && (this.board.getGame() !== null)) {
        this.board.getGame().updateHex(this);
      }
    };

    return Hex;

  })();

  this.Crystal = (function(superClass) {
    extend(Crystal, superClass);


    /* Constructs a Crystal and puts it into board b
        @param b - the board this spark belongs to
        @param l - the location of this crystal in (row, col) in the board
        @throws IllegalArgumentException - if there is already hex at row,col, or row,col is OOB.
     */

    function Crystal(board, loc) {
      Crystal.__super__.constructor.call(this, board, loc);
      this.lit = Color.NONE;
      this.canLight = false;
      this.toColor = "";
    }


    /* @Override
        Try to find light like a prism, but don't ever provide light. Thus only look for a provider, don't need to recurse.
        Only find single light color.
     */

    Crystal.prototype.light = function() {
      var lighterChanged, oldLit;
      oldLit = this.lit;
      lighterChanged = this.pruneLighters();
      if (lighterChanged || this.lit === Color.NONE || this.lit === Color.asString(Color.NONE)) {
        this.findLightProviders(this.lit);
        if (this.isLit().length === 0) {
          this.findLightProviders(Color.NONE);
        }
      }
      if (this.isLit().length === 0) {
        this.lit = Color.NONE;
      } else {
        this.lit = this.isLit()[0];
      }
      this.lightChange = oldLit !== this.lit;
      this.toColor = this.lit;
      this.update();
    };


    /* @Override
        Helper method for use in findLight implementations. Tries to find light among neighbors.
        Overrides hex findLightProvider so that it can take any color of light, no matter the side color.
        Only looks for preferred. If preferred is NONE, takes any color. Only takes on e color
     */

    Crystal.prototype.findLightProviders = function(preferred) {
      var c, h, hLit, j, len1, ref;
      ref = this.getNeighbors();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        h = ref[j];
        hLit = h.isLit();
        c = h.colorOfSide(h.indexLinked(this));
        if (!(h instanceof Crystal) && (hLit.length > 0 && (preferred === Color.NONE || indexOf.call(hLit, preferred) >= 0)) && indexOf.call(this.isLit(), c) < 0 && indexOf.call(hLit, c) >= 0) {
          this.lighters[h.loc.toString()] = c;
        }
      }
    };


    /* @Override
        All sides of this crystal are the color of its lighter. (Not that this can provide light)
     */

    Crystal.prototype.colorOfSide = function(n) {
      if (n < 0 || n > Hex.SIDES - 1) {
        throw "Can't find color of side " + n + " of " + this;
      }
      if (this.lit != null) {
        return this.lit;
      } else {
        return Color.NONE;
      }
    };


    /* Interacting with a Crystal does nothing - do nothing here */

    Crystal.prototype.click = function() {};

    Crystal.prototype.anticlick = function() {};

    return Crystal;

  })(Hex);

  this.Prism = (function(superClass) {
    extend(Prism, superClass);

    Prism.ROTATE_CLOCKWISE = true;


    /* Constructs a Prism and puts it into board b
       @param b - the board this prism belongs to
       @param l - the location of this prism in (row, col) in the board
       @param colors - the colors of this prism, in clockwise order starting with the top. Can be null, then set later.
       @throws IllegalArgumentException - if there is already hex at row,col, or row,col is OOB, or if colors is nonnull and length != SIDES.
     */

    function Prism(board, loc, colors) {
      Prism.__super__.constructor.call(this, board, loc);
      this.setColorCircle(colors);
      this.prevRotation = 0;
      this.currentRotation = 0;
      this.targetRotation = 0;
      this.canLight = true;
    }


    /* Returns the colors of this prism, clockwise from the current top */

    Prism.prototype.colorArray = function() {
      return this.colorCircle.toArray();
    };


    /* Allows setting the ColorCircle, but only if it isn't set yet (is null).
       @throws IllegalArgumentException if the colorCircle is currently non-null
     */

    Prism.prototype.setColorCircle = function(colors) {
      if (this.colorCircle !== void 0 && this.colorCircle !== null && this.colorCircle.length > 0) {
        return;
      }
      this.colorCircle = ColorCircle.fromArray(colors);
    };

    Prism.prototype.rotate = function() {
      this.board.moves++;
      this.colorCircle = this.colorCircle.prev;
      this.targetRotation++;
    };

    Prism.prototype.rotateCounter = function() {
      this.board.moves++;
      this.colorCircle = this.colorCircle.next;
      this.targetRotation--;
    };


    /* @Override
        Returns the colorCircle at the correct index for the color of a given side
     */

    Prism.prototype.colorOfSide = function(n) {
      if (n < 0 || n > Hex.SIDES - 1) {
        throw "Illegal Side Number " + n;
      }
      return this.colorCircle.toArray()[n];
    };


    /* Returns the number of sides of this that are the specified color */

    Prism.prototype.colorCount = function(c) {
      var col, count, j, len1, ref;
      if (!isNaN(c)) {
        c = Color.asString(c).toLowerCase();
      } else {
        c = c.toLowerCase();
      }
      count = 0;
      ref = this.colorArray();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        col = ref[j];
        if (c === col) {
          count++;
        } else {

        }
      }
      return count;
    };


    /* @Override
       Tries to find light by looking at all neighbor hexes that this isn't providing light to
       Tries to stay the same color of light if multiple are avaliable. Otherwise chooses arbitrarily.
       Returns the color this is lit at the end of the procedure, false otherwise
     */

    Prism.prototype.light = function() {
      var c, j, len1, len2, oldLit, p, ref;
      oldLit = this.isLit();
      if (this.canLight) {
        this.pruneLighters();
        this.stopProvidingLight();
        this.findLightProviders(Color.NONE);
        this.provideLight();
      } else {
        this.lighters = {};
        this.stopProvidingLight();
      }
      ref = this.isLit;
      for (j = 0, len1 = ref.length; j < len1; j++) {
        c = ref[j];
        if (indexOf.call(oldLit, c) < 0) {
          this.lightChange = true;
        }
      }
      for (p = 0, len2 = oldLit.length; p < len2; p++) {
        c = oldLit[p];
        if (indexOf.call(this.isLit, c) < 0) {
          this.lightChange = true;
        }
      }
      this.update();
    };


    /* Default behavior for a Prism is to rotate. Rotates clockwise if ROTATE_CLOCKWISE, rotates counterclockwise otherwise. */

    Prism.prototype.click = function() {
      if (Prism.ROTATE_CLOCKWISE) {
        return this.rotate();
      } else {
        return this.rotateCounter();
      }
    };


    /* Does the opposite of the default behavior. Mwa haha! */

    Prism.prototype.anticlick = function() {
      if (!Prism.ROTATE_CLOCKWISE) {
        return this.rotate();
      } else {
        return this.rotateCounter();
      }
    };

    return Prism;

  })(Hex);

  this.Spark = (function(superClass) {
    extend(Spark, superClass);


    /* Constructs a Spark and puts it into board b
       @param b - the board this spark belongs to
       @param l - the location of this spark in (row, col) in the board
       @param colors - the colors of this spark, in clockwise order starting with the top. Can be null, then set later.
       @throws IllegalArgumentException - if there is already hex at row,col, or row,col is OOB, or if colors is nonnull and length == 0.
     */

    function Spark(board, loc, colors) {
      Spark.__super__.constructor.call(this, board, loc);
      this.setAvailableColors(colors);
      this.toColor = "";
    }


    /* Returns the current color of this spark */

    Spark.prototype.getColor = function() {
      return this.availableColors.getColor();
    };


    /* Makes this spark use the next available color. Relights and redraws */

    Spark.prototype.useNextColor = function() {
      this.availableColors = this.availableColors.getNext();
      this.light();
      this.update();
    };


    /* Makes this spark use the previous available color. Relights and redraws */

    Spark.prototype.usePreviousColor = function() {
      this.availableColors = this.availableColors.getPrevious();
      this.light();
      this.update();
    };


    /* Returns the available colors of this spark. */

    Spark.prototype.getAvailableColors = function() {
      return this.availableColors.toArray();
    };


    /*Allows setting the ColorCircle
     */

    Spark.prototype.setAvailableColors = function(colors) {
      this.availableColors = ColorCircle.fromArray(colors);
    };


    /* @Override
        Sparks always find light because they always light themselves. No setting of fields neccesary
     */

    Spark.prototype.light = function() {
      this.stopProvidingLight();
      this.provideLight();
    };


    /* @Override
        Default behavior for a spark is to switch to the next available color
     */

    Spark.prototype.click = function() {
      this.useNextColor();
      this.toColor = this.getColor();
      this.lightChange = true;
    };

    Spark.prototype.anticlick = function() {
      this.usePreviousColor();
      this.toColor = this.getColor();
      this.lightChange = true;
    };


    /* @Override
        Overrides Hex isLit() because Sparks are always lit
     */

    Spark.prototype.isLit = function() {
      var l;
      l = [];
      l.push(this.getColor());
      return l;
    };


    /* @Override
        Overrides Hex colorOfSide(), all color of lit
     */

    Spark.prototype.colorOfSide = function(n) {
      return this.getColor();
    };

    return Spark;

  })(Hex);

}).call(this);
