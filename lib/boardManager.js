// Generated by CoffeeScript 1.9.3

/* Front end maintenence on board objects - loading, creating view for, etc */

/* Clears board and associated sprites from screen, usually in anticipation of new board being loaded */
var modulo = function(a, b) { return (+a % (b = +b) + b) % b; };

this.clearBoard = function() {
  var i, j, k, l, len, len1, len2, len3, m, n, o, p, pan, ref, ref1, ref2, ref3, ref4, spr, sprToRemove;
  sprToRemove = [];
  ref = this.menu.children[this.goalContainerIndex].children;
  for (k = 0, len = ref.length; k < len; k++) {
    spr = ref[k];
    sprToRemove.push(spr);
  }
  ref1 = this.stage.children[1].children;
  for (l = 0, len1 = ref1.length; l < len1; l++) {
    spr = ref1[l];
    sprToRemove.push(spr);
  }
  for (i = m = 1, ref2 = this.stage.children.length - 1; m <= ref2; i = m += 1) {
    ref3 = this.stage.children[i].children;
    for (n = 0, len2 = ref3.length; n < len2; n++) {
      pan = ref3[n];
      for (j = o = 1, ref4 = pan.children.length; o <= ref4; j = o += 1) {
        spr = pan.children[j];
        sprToRemove.push(spr);
      }
    }
  }
  for (p = 0, len3 = sprToRemove.length; p < len3; p++) {
    spr = sprToRemove[p];
    if (spr != null) {
      spr.parent.removeChild(spr);
    }
  }
  this.BOARD = null;
};


/* Called when the board is loaded */

this.onBoardLoad = function() {
  var c, color, colors, fix, goalArr, goalBoard, goalCount, goalStyle, h, i, k, key, l, len, len1, len2, len3, len4, m, n, o, p, pushCoef, q, r, ref, ref1, ref2, ref3, ref4, ref5, removeCount, s, spaceCoef, spark, spr, text, use, val;
  colors = window.BOARD.colorsPresent();
  goalBoard = new Board(colors.length, 1);
  i = 0;
  for (k = 0, len = colors.length; k < len; k++) {
    color = colors[k];
    goalCount = window.BOARD[color.toUpperCase()];
    if (goalCount > 0) {
      c = new Crystal(goalBoard, new Loc(i, 0));
      c.lit = color;
      i++;
    }
  }
  this.goalContainer.count = i;
  spaceCoef = 5 / 6;
  pushCoef = 1 / 4;
  ref = goalBoard.allHexesOfClass("Crystal");
  for (l = 0, len1 = ref.length; l < len1; l++) {
    c = ref[l];
    spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/crystal.png");
    spr.lit = false;
    spr.color = c.lit;
    spr.hex = c;
    spr.position.x = c.loc.row * this.hexRad * spaceCoef;
    spr.anchor.x = spr.anchor.y = 0.5;
    spr.scale.x = spr.scale.y = 0.25;
    c.spr = spr;
    this.updateLight(c);
    this.goalContainer.addChild(spr);
    goalCount = window.BOARD[c.lit.toUpperCase()];
    this.goalContainer.colorCount[c.lit.toUpperCase()] = goalCount;
    goalStyle = this.menuContentStyle;
    text = new PIXI.Text("0/" + goalCount, goalStyle);
    text.position.x = c.loc.row * this.hexRad * spaceCoef + this.hexRad * pushCoef;
    text.position.y = -12;
    text.color = c.lit;
    text.tint = this.Color.hexValueForLit(text.color);
    this.goalContainer.addChild(text);
  }
  if (!this.initted) {
    window.initMenu();
    this.menu.children[7].click();
    this.initted = true;
  }
  goalArr = [];
  for (m = 0, len2 = colors.length; m < len2; m++) {
    c = colors[m];
    for (i = n = 1, ref1 = window.BOARD[c.toUpperCase()]; n <= ref1; i = n += 1) {
      goalArr.push(c.toUpperCase());
    }
  }
  fix = function(h, cir) {
    i = 0;
    while (!h.colorCircle.matches(ColorCircle.fromArray(val))) {
      h.rotate();
      i++;
      if (i === 6) {
        console.error("Rotated six times, no match!");
        break;
      }
      h.targetRotation = 0;
    }
  };
  if (this.difficulty === this.Game.EASY) {
    removeCount = goalArr.length / 2;
    ref2 = this.BOARD.Locked;
    for (key in ref2) {
      val = ref2[key];
      h = this.BOARD.getHex(Loc.fromString(key));
      fix(h, ColorCircle.fromArray(val));
      h.isLocked = true;
    }
  }
  if (this.difficulty === this.Game.MEDIUM) {
    removeCount = goalArr.length / 4;
    use = true;
    ref3 = this.BOARD.Locked;
    for (key in ref3) {
      val = ref3[key];
      if (use) {
        h = this.BOARD.getHex(Loc.fromString(key));
        fix(h, ColorCircle.fromArray(val));
        h.isLocked = true;
      }
      use = !use;
    }
  }
  if (this.difficulty === this.Game.HARD) {
    removeCount = 0;
  }
  this.BOARD.moves = 0;
  for (i = o = 1, ref4 = removeCount; o <= ref4; i = o += 1) {
    r = Math.floor(Math.random() * goalArr.length);
    window.BOARD[goalArr[i]]--;
    goalArr.splice(i, 1);
  }
  for (p = 0, len3 = colors.length; p < len3; p++) {
    c = colors[p];
    if (window.BOARD[c.toUpperCase()] === 0) {
      ref5 = window.BOARD.allHexesOfClass("Spark");
      for (q = 0, len4 = ref5.length; q < len4; q++) {
        spark = ref5[q];
        s = spark.getAvailableColors();
        s.splice(s.indexOf(c), 1);
        spark.setAvailableColors(s);
      }
    }
  }
  window.BOARD.relight();
  document.body.appendChild(renderer.view);
  window.resize();
  window.drawBoard();
  return this.resize();
};


/* Draws the Board in BOARD on the stage. */

this.drawBoard = function() {
  var h, k, len, ref;
  ref = this.BOARD.allHexes();
  for (k = 0, len = ref.length; k < len; k++) {
    h = ref[k];
    this.createSpriteForHex(h);
  }
};

this.hexRad = 110;


/* Creates a single sprite for a hex and adds it to stage */

this.createSpriteForHex = function(hex) {
  var backpanel, c, combo, con, cpanel, diff, fixAndRotateConnector, i, indices, j, k, l, len, len1, m, n, o, pairCombos, radTo60Degree, ref, ref1, ref2, ref3, ref4, sideOne, sideTwo, spr, theSide;
  if (typeof hex.panel === "undefined" || hex.panel === null) {
    radTo60Degree = 1.04719755;
    backpanel = new PIXI.DisplayObjectContainer();
    backpanel.position.x = hex.loc.col * this.hexRad * 3 / 4 * 1.11 + this.hexRad * (5 / 8);
    backpanel.position.y = hex.loc.row * this.hexRad + this.hexRad * (5 / 8);
    if (hex.loc.col % 2 === 1) {
      backpanel.position.y += this.hexRad / 2;
    }
    backpanel.pivot.x = 0.5;
    backpanel.pivot.y = 0.5;
    if (hex instanceof Prism) {
      spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/hex-back.png");
    } else if (hex instanceof Crystal) {
      spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/crystal.png");
    } else if (hex instanceof Spark) {
      spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/spark.png");
    }
    spr.lit = false;
    spr.anchor.x = 0.5;
    spr.anchor.y = 0.5;
    spr.hex = hex;
    backpanel.addChild(spr);
    backpanel.spr = spr;
    hex.spr = spr;
    this.base.addChild(backpanel);
    hex.backPanel = backpanel;
    fixAndRotateConnector = function(connector, side, color, panel) {
      connector.linked = false;
      connector.anchor.x = 0.5;
      connector.anchor.y = 0.5;
      connector.color = color;
      connector.rotation = side * radTo60Degree;
      connector.panel = panel;
      panel.addChild(connector);
    };
    if (hex instanceof Prism) {
      hex.connectors = [];
      ref = Color.regularColors();
      for (k = 0, len = ref.length; k < len; k++) {
        c = ref[k];
        if (hex.colorCount(c) > 0) {
          cpanel = new PIXI.DisplayObjectContainer();
          cpanel.position.x = hex.loc.col * this.hexRad * 3 / 4 * 1.11 + this.hexRad * (5 / 8);
          cpanel.position.y = hex.loc.row * this.hexRad + this.hexRad * (5 / 8);
          if (hex.loc.col % 2 === 1) {
            cpanel.position.y += this.hexRad / 2;
          }
          cpanel.pivot.x = 0.5;
          cpanel.pivot.y = 0.5;
          cpanel.color = c;
          indices = [];
          for (i = l = 0, ref1 = Hex.SIDES - 1; l <= ref1; i = l += 1) {
            if (hex.colorOfSide(i) === c.toLowerCase()) {
              indices.push(i);
            }
          }
          if (indices.length === 1) {
            con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-none.png");
            con.sides = [indices[0]];
            con.tint = this.Color.hexValueForUnlit(this.Color.fromString(c));
            hex.connectors.push(con);
            fixAndRotateConnector(con, indices[0], c, cpanel);
          } else {
            pairCombos = [];
            for (i = m = 0, ref2 = indices.length - 1; m <= ref2; i = m += 1) {
              for (j = n = ref3 = i + 1, ref4 = indices.length - 1; n <= ref4; j = n += 1) {
                pairCombos.push(indices[j] * 10 + indices[i]);
              }
            }
            for (o = 0, len1 = pairCombos.length; o < len1; o++) {
              combo = pairCombos[o];
              sideOne = combo % 10;
              sideTwo = Math.floor(combo / 10);
              diff = modulo(sideTwo - sideOne, Hex.SIDES);
              theSide = -1;
              switch (diff) {
                case 0:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-opposite.png");
                  theSide = sideTwo;
                  break;
                case 1:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-adjacent.png");
                  theSide = sideTwo;
                  break;
                case 2:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-far-neighbor.png");
                  theSide = sideTwo;
                  break;
                case 3:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-opposite.png");
                  theSide = sideOne;
                  break;
                case 4:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-far-neighbor.png");
                  theSide = sideOne;
                  break;
                case 5:
                  con = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector-adjacent.png");
                  theSide = sideOne;
              }
              con.sides = [sideOne, sideTwo];
              con.tint = this.Color.hexValueForUnlit(this.Color.fromString(c));
              hex.connectors.push(con);
              fixAndRotateConnector(con, theSide, c, cpanel);
            }
          }
          this.base.addChild(cpanel);
        }
      }
    } else if (hex instanceof Crystal) {
      spr.color = hex.lit === Color.NONE ? "NONE" : hex.lit.toUpperCase();
      spr.panel = backpanel;
      this.updateLight(hex);
    } else if (hex instanceof Spark) {
      spr.color = hex.getColor().toUpperCase();
      spr.panel = backpanel;
      this.updateLight(hex);
    }
    if (hex.isLocked) {
      backpanel.interactive = false;
      spr.alpha = 0;
    } else {
      backpanel.interactive = true;
    }
    backpanel.click = function(event) {
      if (window.gameOn) {
        if (!event.originalEvent.shiftKey) {
          hex.click();
        } else {
          hex.anticlick();
        }
      }
    };
    backpanel.tap = backpanel.click;
  }
  return hex.panel;
};
