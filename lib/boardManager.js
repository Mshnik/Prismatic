// Generated by CoffeeScript 1.7.1

/* Front end maintenence on board objects - loading, creating view for, etc */


/* Clears board and associated sprites from screen, usually in anticipation of new board being loaded */

(function() {
  this.clearBoard = function() {
    var i, pan, spr, sprToRemove, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    sprToRemove = [];
    _ref = this.menu.children[this.goalContainerIndex].children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      pan = _ref[_i];
      _ref1 = pan.children;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        spr = _ref1[_j];
        sprToRemove.push(spr);
      }
    }
    _ref2 = this.stage.children[1].children;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      spr = _ref2[_k];
      sprToRemove.push(spr);
    }
    for (i = _l = 1, _ref3 = this.stage.children.length - 1; 1 <= _ref3 ? _l <= _ref3 : _l >= _ref3; i = 1 <= _ref3 ? ++_l : --_l) {
      _ref4 = this.stage.children[i].children;
      for (_m = 0, _len3 = _ref4.length; _m < _len3; _m++) {
        pan = _ref4[_m];
        _ref5 = pan.children;
        for (_n = 0, _len4 = _ref5.length; _n < _len4; _n++) {
          spr = _ref5[_n];
          sprToRemove.push(spr);
        }
      }
    }
    for (_o = 0, _len5 = sprToRemove.length; _o < _len5; _o++) {
      spr = sprToRemove[_o];
      if (spr != null) {
        spr.parent.removeChild(spr);
      }
    }
    this.BOARD = null;
  };


  /* Called when the board is loaded */

  this.onBoardLoad = function() {
    var c, color, colors, fix, goalArr, goalBoard, goalCount, goalStyle, h, i, key, pushCoef, r, removeCount, s, spaceCoef, spark, spr, text, use, val, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref2, _ref3, _ref4;
    if (!this.initted) {
      window.initMenu();
      this.menu.children[7].click();
      this.initted = true;
    }
    colors = window.BOARD.colorsPresent();
    goalArr = [];
    for (_i = 0, _len = colors.length; _i < _len; _i++) {
      c = colors[_i];
      for (i = _j = 1, _ref = window.BOARD[c.toUpperCase()]; _j <= _ref; i = _j += 1) {
        goalArr.push(c.toUpperCase());
      }
    }
    fix = function(h, cir) {
      i = 0;
      while (!h.colorCircle.matches(ColorCircle.fromArray(val))) {
        h.rotate();
        i++;
        if (i === 6) {
          console.error("Rotated six times, no match!");
          break;
        }
        h.targetRotation = 0;
      }
    };
    if (this.difficulty === this.Game.EASY) {
      removeCount = goalArr.length / 2;
      _ref1 = this.BOARD.Locked;
      for (key in _ref1) {
        val = _ref1[key];
        h = this.BOARD.getHex(Loc.fromString(key));
        fix(h, ColorCircle.fromArray(val));
        h.isLocked = true;
      }
    }
    if (this.difficulty === this.Game.MEDIUM) {
      removeCount = goalArr.length / 4;
      use = true;
      _ref2 = this.BOARD.Locked;
      for (key in _ref2) {
        val = _ref2[key];
        if (use) {
          h = this.BOARD.getHex(Loc.fromString(key));
          fix(h, ColorCircle.fromArray(val));
          h.isLocked = true;
        }
        use = !use;
      }
    }
    if (this.difficulty === this.Game.HARD) {
      removeCount = 0;
    }
    this.BOARD.moves = 0;
    for (i = _k = 1; _k <= removeCount; i = _k += 1) {
      r = Math.floor(Math.random() * goalArr.length);
      window.BOARD[goalArr[i]]--;
      goalArr.splice(i, 1);
    }
    goalBoard = new Board(colors.length, 1);
    i = 0;
    for (_l = 0, _len1 = colors.length; _l < _len1; _l++) {
      color = colors[_l];
      goalCount = window.BOARD[color.toUpperCase()];
      if (goalCount > 0) {
        c = new Crystal(goalBoard, new Loc(i, 0));
        c.lit = color;
        i++;
      }
    }
    this.goalContainer.count = i;
    spaceCoef = 5 / 6;
    pushCoef = 1 / 4;
    _ref3 = goalBoard.allHexesOfClass("Crystal");
    for (_m = 0, _len2 = _ref3.length; _m < _len2; _m++) {
      c = _ref3[_m];
      spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/crystal.png");
      spr.lit = false;
      spr.color = c.lit;
      spr.hex = c;
      spr.position.x = c.loc.row * this.hexRad * spaceCoef;
      spr.anchor.x = spr.anchor.y = 0.5;
      spr.scale.x = spr.scale.y = 0.25;
      this.goalContainer[c.lit.toUpperCase()].addChild(spr);
      goalCount = window.BOARD[c.lit.toUpperCase()];
      this.goalContainer[c.lit.toUpperCase()].goalCount = goalCount;
      goalStyle = this.menuContentStyle;
      text = new PIXI.Text("0/" + goalCount, goalStyle);
      text.position.x = c.loc.row * this.hexRad * spaceCoef + this.hexRad * pushCoef;
      text.position.y = -12;
      text.color = c.lit;
      this.goalContainer[c.lit.toUpperCase()].addChild(text);
    }
    for (_n = 0, _len3 = colors.length; _n < _len3; _n++) {
      c = colors[_n];
      if (window.BOARD[c.toUpperCase()] === 0) {
        this.colorContainers[c.toUpperCase()].alpha = 0;
        _ref4 = window.BOARD.allHexesOfClass("Spark");
        for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
          spark = _ref4[_o];
          s = spark.getAvailableColors();
          s.splice(s.indexOf(c), 1);
          spark.setAvailableColors(s);
        }
      } else {
        this.colorContainers[c.toUpperCase()].alpha = 1;
      }
    }
    window.BOARD.relight();
    document.body.appendChild(renderer.view);
    window.resize();
    window.drawBoard();
    return this.resize();
  };


  /* Creates a dummy board and adds to scope. Mainly for testing */

  this.createDummyBoard = function() {
    this.BOARD = this.Board.makeBoard(4, 12, 3);
    this.onBoardLoad();
  };


  /* Draws the Board in BOARD on the stage. */

  this.drawBoard = function() {
    var h, _i, _len, _ref;
    _ref = this.BOARD.allHexes();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      this.createSpriteForHex(h);
    }
  };

  this.hexRad = 110;


  /* Creates a single sprite for a hex and adds it to stage */

  this.createSpriteForHex = function(hex) {
    var backpanel, c, col, core, coreContainer, coreRad, cpanel, cr, cumulative, i, point, radTo60Degree, sidePanels, spr, _i, _j, _len, _ref, _ref1;
    if (typeof hex.panel === "undefined" || hex.panel === null) {
      radTo60Degree = 1.04719755;
      backpanel = new PIXI.DisplayObjectContainer();
      backpanel.position.x = hex.loc.col * this.hexRad * 3 / 4 * 1.11 + this.hexRad * (5 / 8);
      backpanel.position.y = hex.loc.row * this.hexRad + this.hexRad * (5 / 8);
      if (hex.loc.col % 2 === 1) {
        backpanel.position.y += this.hexRad / 2;
      }
      backpanel.pivot.x = 0.5;
      backpanel.pivot.y = 0.5;
      if (hex instanceof Prism) {
        spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/hex-back.png");
      } else if (hex instanceof Crystal) {
        spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/crystal.png");
      } else if (hex instanceof Spark) {
        spr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/spark.png");
      }
      spr.lit = false;
      spr.anchor.x = 0.5;
      spr.anchor.y = 0.5;
      spr.hex = hex;
      backpanel.addChild(spr);
      backpanel.spr = spr;
      hex.spr = spr;
      sidePanels = [];
      if (hex instanceof Prism) {
        coreRad = 32;
        cumulative = [0.01, -0.02, 0.01, 0, 0, 0.02];
        for (i = _i = 0, _ref = Hex.SIDES - 1; _i <= _ref; i = _i += 1) {
          c = hex.colorOfSide(i);
          if (!isNaN(c)) {
            c = Color.asString(c).toUpperCase();
          } else {
            c = c.toUpperCase();
          }
          point = new PIXI.Point(coreRad * Math.cos((i - 2) * 2 * Math.PI / Hex.SIDES + radTo60Degree / 2 + cumulative[i]), coreRad * Math.sin((i - 2) * 2 * Math.PI / Hex.SIDES + radTo60Degree / 2 + cumulative[i]));
          cr = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/connector_off.png");
          cr.linked = false;
          cr.anchor.x = 0.5;
          cr.anchor.y = 0.8;
          cr.rotation = i * radTo60Degree;
          cr.position.x = point.x;
          cr.position.y = point.y;
          cr.side = i;
          cr.color = c;
          cpanel = new PIXI.DisplayObjectContainer();
          cpanel.position.x = hex.loc.col * this.hexRad * 3 / 4 * 1.11 + this.hexRad * (5 / 8);
          cpanel.position.y = hex.loc.row * this.hexRad + this.hexRad * (5 / 8);
          if (hex.loc.col % 2 === 1) {
            cpanel.position.y += this.hexRad / 2;
          }
          cpanel.pivot.x = 0.5;
          cpanel.pivot.y = 0.5;
          cpanel.addChild(cr);
          cr.panel = cpanel;
          sidePanels.push(cpanel);
          this.colorContainers[c].unlit.addChild(cpanel);
          coreContainer = {};
          _ref1 = Color.regularColors();
          for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
            col = _ref1[_j];
            col = !isNaN(col) ? Color.asString(col).toUpperCase() : col.toUpperCase();
            core = PIXI.Sprite.fromImage(this.siteprefix + "assets/img/core.png");
            core.position.x = hex.loc.col * this.hexRad * 3 / 4 * 1.11 + this.hexRad * (7 / 16);
            core.position.y = hex.loc.row * this.hexRad + this.hexRad * (7 / 16) - 0.5;
            if (hex.loc.col % 2 === 1) {
              core.position.y += this.hexRad / 2;
            }
            core.pivot.x = 0.5;
            core.pivot.y = 0.5;
            core.alpha = 0;
            coreContainer[col] = core;
            this.colorContainers[col].lit.addChild(core);
          }
        }
      } else if (hex instanceof Crystal) {
        spr.color = hex.lit === Color.NONE ? "NONE" : hex.lit.toUpperCase();
        spr.panel = backpanel;
        this.toUnlit(spr);
      } else if (hex instanceof Spark) {
        spr.color = hex.getColor().toUpperCase();
        spr.panel = backpanel;
        this.toLit(spr);
      }
      hex.backPanel = backpanel;
      hex.colorPanels = sidePanels;
      hex.cores = coreContainer;
      if (hex instanceof Prism) {
        this.base.addChild(backpanel);
      }
      if (hex.isLocked) {
        backpanel.interactive = false;
        spr.tint = 0xFFFF21;
      } else {
        backpanel.interactive = true;
      }
      backpanel.click = function(event) {
        if (window.gameOn) {
          if (!event.originalEvent.shiftKey) {
            hex.click();
          } else {
            hex.anticlick();
          }
        }
      };
    }
    return hex.panel;
  };

}).call(this);
