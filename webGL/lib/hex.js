// Generated by CoffeeScript 1.7.1

/* Abstract parent of all tiles */
var Hex,
  __modulo = function(a, b) { return (a % b + +b) % b; },
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Hex = (function() {
  Hex.SIDES = 6;

  Hex.NEIGHBOR_COORDINATES = [[new Loc(-1, 0), new Loc(-1, 1), new Loc(0, 1), new Loc(1, 0), new Loc(0, -1), new Loc(-1, -1)], [new Loc(-1, 0), new Loc(0, 1), new Loc(1, 1), new Loc(1, 0), new Loc(1, -1), new Loc(0, -1)]];


  /*Stores Board b and Point p as board and location in this hex.
     Throws IllegalArgumentException if b is null, point p is already occupied on board b,
     Or if the location is out of bounds.
   */

  function Hex(board, loc) {
    var a, vec;
    try {
      if (board === null) {
        throw new IllegalArgumentException("Can't put hex into null board");
      }
      if (b.getHex(loc) !== null) {
        throw new IllegalArgumentException("Board " + board + " already has hex at position " + "(" + loc.row + "," + loc.col + "), can't construct new hex there.");
      }
    } catch (_error) {
      a = _error;
      throw new IllegalArgumentException("Can't construct hex in " + board + " at " + loc + ": " + a.getMessage());
    }
    this.board = board;
    this.loc = loc;
    this.neighbors = (function() {
      var _i, _len, _ref, _results;
      _ref = Hex.NEIGHBOR_COORDINATES[__modulo(loc.col, 2)];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vec = _ref[_i];
        _results.push(new Loc(loc.row + vec.row, loc.col + vec.col));
      }
      return _results;
    })();
    this.neighborsUpdated = true;
    this.neighborHexes = [];
    this.board.setHex(this, loc.row, loc.col);
    this.lighters = [];
  }


  /*Returns the neighbors of this hex, clockwise from above. Will always return an array of lenght SIDES,
     but may contain nulls.
     Spots that this does not have a neighbor (off the board) are stored as null.
     Part of lazy calculation of neighborHexes - only updates if neighborsUpdated is true.
     Otherwise returns the (already calculated) neighborHexes
   */

  Hex.prototype.getNeighborsWithBlanks = function() {
    var e, l, neighborsUpdated;
    if (neighborsUpdated) {
      this.neighborHexes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.neighbors;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          try {
            _results.push(board.getHex(l.row, l.col));
          } catch (_error) {
            e = _error;
            _results.push(null);
          }
        }
        return _results;
      }).call(this);
      neighborsUpdated = false;
      return this.neighborHexes;
    } else {
      return this.neighborHexes;
    }
  };


  /*Returns the neighbors of this hex, clockwise from above, with nulls removed. 
     Thus no null elements, but resulting array has length 0 <= x <= SIDES
   */

  Hex.prototype.getNeighbors = function() {
    var a, h, _i, _len, _results;
    a = this.getNeighborsWithBlanks;
    _results = [];
    for (_i = 0, _len = a.length; _i < _len; _i++) {
      h = a[_i];
      if (h(!null)) {
        _results.push(h);
      } else {

      }
    }
    return _results;
  };

  Hex.prototype.indexLinked = function(h) {
    return this.board.indexLinked(this, h);
  };

  Hex.prototype.colorLinked = function(h) {
    return this.board.colorLinked(this, h);
  };


  /* Returns the colors this is lit. Returns empty if this isn't lit */

  Hex.prototype.isLit = function() {
    var key, val, _ref, _results;
    _ref = this.lighters;
    _results = [];
    for (key in _ref) {
      val = _ref[key];
      _results.push(val);
    }
    return _results;
  };


  /* Returns a set of locations (hexes) that all eventually provide light to this of a given color.
      Can be used to prevent cycles from forming.
   */

  Hex.prototype.lighterSet = function(c) {
    var arr, k, key, val, _i, _len, _ref, _ref1;
    arr = null;
    _ref = this.lighters;
    for (key in _ref) {
      val = _ref[key];
      if (val === c) {
        arr.push(key);
        _ref1 = key.lighterSet(c);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          k = _ref1[_i];
          arr.push(k);
        }
      } else {

      }
    }
    return arr;
  };


  /* Fixes light for this hex. Must be implemented in subclasses. */

  Hex.prototype.light = function() {
    throw new RuntimeException("Cannot instantiate Hex Class - light method must be overriden");
  };


  /* Helper method for use in light implementations. Removes lighters that can't light this anymore from lighters map
      Returns true if at least one lighter was removed, false otherwise
   */

  Hex.prototype.pruneLighters = function() {
    var c, h, l, oldArr, val, y, _i, _len;
    oldArr = (function() {
      var _ref, _results;
      _ref = this.lighters;
      _results = [];
      for (y in _ref) {
        val = _ref[y];
        _results.push(y);
      }
      return _results;
    }).call(this);
    for (_i = 0, _len = oldArr.length; _i < _len; _i++) {
      l = oldArr[_i];
      h = this.board.getHex(l);
      c = this.colorLinked(h);
      if (c === Color.NONE || __indexOf.call(h.isLit(), c) < 0) {
        delete this.lighters.l;
      }
    }
    return oldArr.length !== Object.keys(this.lighters).length;
  };


  /* Helper method for use in findLight implementations. Tells neighbors this is currently lighting to look elsewhere */

  Hex.prototype.stopProvidingLight = function() {
    var c, cond1, cond2, cond3, h, _i, _len, _ref;
    c = this.isLit();
    _ref = this.getNeighbors();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      cond1 = this.loc in h.lighters;
      cond2 = !(h.lighters[this.loc] in c);
      cond3 = colorLinked(h)(!h.lighters[this.loc]);
      if (cond1 && (cond2 || cond3)) {
        h.light();
      }
    }
  };


  /* Helper method for use in findLight implementations. Tells neighbors that this is now lit, 
     maybe get light from this, if not already or this getting light from that.
     If this isn't lit, do nothing. 
     
     Note: Always try to provide light to crystal, never try to provide light to spark. Neither of these recurse, so no trouble.
     Sparks can always provide light, others can only provide light if they have a lighter
   */

  Hex.prototype.provideLight = function() {
    var c, h, hLit, lit, _i, _len, _ref;
    if (this instanceof Spark || (Object.keys(this.lighters).length > 0)) {
      lit = this.isLit();
      _ref = getNeighbors();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        h = _ref[_i];
        hLit = h.isLit();
        c = this.colorLinked(h);
        if (!(h instanceof Spark) && ((h instanceof Crystal && hlit.length === 0) || (h instanceof Prism && c in lit && !c in hLit))) {
          h.light();
        }
      }
    }
  };


  /* Helper method for use in findLight implementations. Tries to find light among neighbors.
      If a link is found, sets that neighbor as lighter. If no link found, sets lighter to null.
      Only looks for preferred. If preferred is NONE, takes any color.
   */

  Hex.prototype.findLightProvider = function(preferred) {
    var c, h, hLit, _i, _len, _ref;
    _ref = this.getNeighbors();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      h = _ref[_i];
      hLit = h.isLit();
      c = this.colorLinked(h);
      if (c in hLit && (preferred === Color.NONE || preferred === c) && __indexOf.call(h.lighterSet(c), this) < 0) {
        lighters[h.loc] = c;
      }
    }
  };


  /* Returns the color of side n of this hex (where side 0 is the top).
     IllegalArgumentException if n < 0, n > SIDES - 1
   */

  Hex.prototype.colorOfSide = function(n) {
    throw new RuntimeException("Cannot instantiate Hex Class - colorOfSide method must be overriden");
  };


  /* Perform default behavior for interacting with this hex */

  Hex.prototype.click = function(n) {
    throw new RuntimeException("Cannot instantiate Hex Class - click method must be overriden");
  };


  /* Returns the location of this hex as the string for this hex */

  Hex.prototype.toString = function() {
    return this.loc.toString();
  };


  /* Two hexes are equal if their boards and their locations are the same */

  Hex.prototype.equals = function(o) {
    var h;
    if (!(o instanceof Hex)) {
      return false;
    } else {
      h = Hex(o);
      return this.board === h.board && this.location === h.location;
    }
  };


  /* Signifies that this has been changed; tells the game (if any) to update this as necessary. */

  Hex.prototype.update = function() {
    if ((this.board(!null)) && (this.board.getGame()(!null))) {
      this.board.getGame().updateHex(this);
    }
  };

  return Hex;

})();
